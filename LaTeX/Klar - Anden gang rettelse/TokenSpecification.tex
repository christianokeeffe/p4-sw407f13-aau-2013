For a compiler to able to distinguish between variables names and types the compiler will need some rules to describe the difference between them. This is done by reserving the words, so called keywords, that are used to describe types, the beginnings and endings of blocks and declaration of statements. A variable may not be named the same as any of the keywords since the compiler can not distinguish if it is a variable name or a reserved keyword.

\subsection{Reserved Keywords}
The reserved keywords for SPLAT are:
\begin{itemize}
\item bool
\item int
\item double
\item char
\item string
\item OR
\item AND
\item true
\item false
\item begin
\item end
\item if
\item else
\item function
\item using
\item return
\item nothing
\item switch
\item case
\item break
\item default
\item from
\item to
\item step
\item while
\item container
\item HIGH
\item LOW
\end{itemize}
This list is used to keep track of which words that are going to be reserved and that way give an overview for the programmer which words they may not use as names for their variables or functions. 

\subsection{Token Specification}
A parser needs a stream of tokens to parse a program correctly. These tokens are generated by a Lexer that reads a stream of input symbols and from a given set of rules, makes the corresponding tokens. A token specification is used to describe the rules the Lexer need in the construction of tokens. Token specification are expressed in way related to regular expressions \citep{sebasta}. Regular expressions are strong at describing patterns which is the core of token production \citep{sipser}.

\begin{tabular}{l l}
%Terminal & Regular Expression \\ \hline
%bool & "bool" \\
%int & "int" \\
%double & "double"\\
%char & "char" \\
%string & "string" \\
%== & "$<--$" \\ 
%|| & "OR" \\
%\&\& & "AND" \\
%< & "<" \\
%> & ">" \\
%<= & "<=" \\
%>= & ">=" \\
%!= & "!=" \\
%= & "=" \\ 
%$\{$ & "begin"\\
%$\}$ & "end"\\
%if & "if" \\
%else & "else" \\
%yy xx(zz) & "function xx returns yy using zz" \\
%void & "nothing" \\
%switch & "switch" \\
%case & "case" \\
%break & "break" \\
%default & "default" \\
%$for(i=xx; i<=yy; xx+=zz)$ & "from xx to yy step zz" \\
%while & "while" \\
%digitalWrite & "container" \\
PRIMITIVETYPE & 'int' | 'double' | 'bool' | 'char' | 'container' | 'string' \\
DIGIT & $[0 - 9]^+$ \\
NOTZERODIGIT & $[1-9][0-9]^*$ \\
LETTER & $[A-Za-z]^+$\\
COMMENT & /* $\dots$ */ \\
WHITESPACE & \\r | \\n | \\t \\
OTHER & $\varepsilon$ \\
%boolean & $[true] \cup [false]$ \\
\end{tabular}

Further work would be making a Lexer to generate a token for the parser. Another options was to find a suited tool for generating a Lexer for the given rules. This is a valid option because making a Lexer can be automated and therefore already exists a lot of good Lexer generators that can be used, see section \ref{sec:KnownLexersAndParsers}.