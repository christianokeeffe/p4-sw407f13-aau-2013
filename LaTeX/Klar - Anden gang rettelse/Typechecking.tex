\section{Type Checking}
\label{sec:typecheck}
In this section we will describe how we type-check the code using the visitor pattern generated by ANTLR \citep{ANTLR}.

\subsection*{Value}
We use a class called "Value" to be able to return almost any type of data through the visitor pattern.
\kode{Value type}{Value}{Value.txt}
This class, as can be seen on listing \ref{lst:Value}, allows us to write expressions like "Value p = new Value(5)", thus we can return the value 5. This can also be used to combine different types and return them as a value. This is useful because we do not always know what type will be returned and this makes it possible to convert everything into the same type which we can evaluate later.
\kode{How to evaluate Value}{isType}{isType.txt}
When we evaluate the type value we use functions like those seen on listing \ref{lst:isType} which returns "true" or "false". In the code example we make use of regular expressions to determine if it is an integer or double by looking at what it contains like numbers and symbols in the defined order. We use similar functions for each type that exists in the language.

\subsection*{Functions}
We have made a class "functions" as seen on listing \ref{lst:Function} to make it easier to store the name, parameters and return value of a function. This will be used to retrieve the specific data that we need. Every time a function is found it is added to our function memory. This allows us to find it when for instance the function is called later in the code. We can then check if the call have the right setup simply by comparing the type and amount of parameters from our memory to the ones that are being used in the call.
\kode{Function class}{Function}{Function.txt}
The code that the programmer writes is intended to be compiled to an Arduino platform and thus needs to have certain functions to work properly, these are the functions "setup" and "loop" and so we check if they are present. Some commands like LCDPrint and RFIDWrite are predefined in the Arduino language and can be used without a declaration, so we have also defined them in our language as seen on listing \ref{lst:LCDPrint}
\kode{Defining LCDPrint}{LCDPrint}{LCDPrint.txt}
We will not implement all Arduino functions because it would take too much time and effort, so we have decided to only take the ones involved with the LCD and RFID. Furthermore we have defined our own functions such as \ref{lst:PourDrink} so we can type check it.
\kode{Predefining function PourDrink}{PourDrink}{PourDrink.txt}

\subsection*{Variables}
In our language "INPUT" and "OUTPUT" would be seen as variables and by default be undefined so we predefined them like seen on listing \ref{lst:OUTPUT}. This is also done for "A0" to "A5" since these are used when determining input and output for the Arduino board. We have defined them with the type "container" because a container can have one of these values as its output.
\kode{Predefining OUTPUT}{OUTPUT}{OUTPUT.txt}
We have made a "variable" class to be make it easier to store and retrieve the necessary data. This class can be seen on listing \ref{lst:Variable}. In this class we have added two boolean expressions to make it easier to handle constants and arrays, so if we meet a constant or an array we set the appropriate expression to true. This will allows us to make a simple check to see if it is allowed to assign a new value to the variable.
\kode{Variable class}{Variable}{Variable.txt}
When we make a declaration we first find the ID and then the type of the ID, then we visit the node assign that traverses the tree all the way down to the factor node.

\subsubsection*{Drink}
Our special type "drink" has its own separate declaration method, the initial part can be seen on listing \ref{lst:DrinkDcl}. First we check if it is a new drink will or will not inherit from another drink. This is done be looking at how many IDs are present, if there are two then it means that will inherit from an existing drink. If there is only one ID then that means a new drink will not inherit from another drink.
\kode{Drink declaration}{DrinkDcl}{DrinkDcl.txt}
Whether or not its inherits from an existing drink, the type checker needs to check if the expressions used in the body are valid containers. If any of the expressions are invalid then an error for the given drink will be added to the list.

\subsection*{Error Handling}
We have made an "error" class to notify the programmer of the mistakes the type checker have found while checking the program. When an error is encountered we send a number and an id to our "error" class as seen on listing \ref{lst:IntError}.
\kode{Int Error}{IntError}{IntError.txt}
Our "error" class contains a switch case an excerpt of this can be seen on listing \ref{lst:Error}. The error found is saved in a list that will be shown, when all the nodes have been visited.
\kode{Switch case error handling}{Error}{Error.txt}