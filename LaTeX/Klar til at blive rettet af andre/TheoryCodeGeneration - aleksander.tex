\subsection{Code Generation}
Code generation is the last phase of a compiler. It is in this phase that the target code is generated. An overview of all the phases in a compiler can be seen on figure \ref{fig:OverviewCompiler2}. Traditionally a compiler generates machine code targeted at a specific architecture. This means that machine code compiled for the Intel x86 architecture will not be able to run on a RISC architecture. The reason why a program compiled against one architecture will not run on another architecture, is that each architecture has a slight different set of instructions. The first phase in the code generation is the instruction selection. Instruction selection is needed exactly because these different instruction sets exists. Another thing the a code generator must take into account is the register allocation and code scheduling, which might be implemented differently on different architectures, hence the different instruction set. It is also obvious, that register allocation is not needed on a machine which has no registers. Here other techniques for storing intermediate values can be used depending on what the specific architecture provides. Recall that the target code need not be by machine code or byte code. A compiler can simply compile high-level language to lower-level language, which means that the target code of course can be for example C. The main task of a \emph{machine code} generator is to choose the right instructions, and to insert the right instructions at the right places, the latter is called the code scheduling. This task is important because some pieces of code might be dependent of other pieces of code. The code generator could then place these pieces of code close together, so no very long jumps, which is more expensive than shorter jumps are used. The code scheduler uses various algorithms to ensure the best position for a given piece of code, these algorithm includes topological sort, and shortest path algorithms. Depending on how the compiler is implemented, the code generator can either generate code from a provided intermediate representation, which is supplied by a translator. This is typically used when the compiler also includes an optimizer, which optimizes the source program to obtain greater execution speeds. If the compiler includes no optimizer, the code-generator can be implemented as a visitor, which traverses the decorated abstract syntax tree provided directly by the type checker. 