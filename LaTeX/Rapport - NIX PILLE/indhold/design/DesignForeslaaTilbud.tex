\label{sec:foreslaatilbud}

\begin{table}[H]
    \begin{tabular}{l}
        \hline
        \textbf{Foreslå tilbud} \\ \hline
        \textbf{Kategori:} Aktiv beregning og aktiv signalering.\\
        \textbf{Formål:} Operationens formål er at analysere brugerens indkøbslister og komme med\\ 
        forslag på tilbud, baseret på de varer de har købt flest af.\\
        \textbf{Input:} Brugerens indkøbslister.\\
        \textbf{Betingelse:} API'en med tilbudene skal være tilgængelig når brugerne har købt en vare et\\
        minimum antal gange.\\
        \textbf{Algoritme:} Operationen går først igennem brugerens indkøbslister og finder fællestræk\\
        i forhold til varernes navne. Operationen kontrollerer de forskellige træk efter nogle\\
        kriterier som filtrerer alle fællestrækkene.\\
        Derefter bliver tilbuds-API'en søgt igennem efter de resterende fællestræk og\\
        operationen returnerer så de resultater søgningen giver.\\
        \textbf{Placering:} I klassen \gaas{Tilbudsanalysator}.\\
        \textbf{Involverede objekter:} Bruger og indkøbslister.\\
        \textbf{Udløsende hændelser:} Tryk på knappen dedikeret til operationen.\\ \hline
    \end{tabular}
\caption{Tabel over funktionen \gaas{Foreslå tilbud}}
\label{tab:foreslaatilbud}
\end{table}

Tabel \ref{tab:foreslaatilbud} specificerer operation \gaas{Foreslå tilbud} mere og giver bedre mulighed for, at arbejde med den, når operationen skal implementeres i den endelige problemløsning. Til at forklare funktions forløb, er der blevet lavet et tilstandsdiagram som kan ses på figur \ref{fig:foreslaatilbud}.

\figur{0.6}{DesignFindTilbudTilstandsiagram.png}{Tilstandsdiagram over funktionen foreslå tilbud.}{fig:foreslaatilbud}

Ud fra analysen af problemområdet blev det fundet, at funktionen \gaas{foreslå tilbud}, ud fra tidligere tilbud, vil gavne produktet. Der findes mange forskellige måder at foreslå tilbud, og ud fra mange forskellige kriterier.
For at nævne nogle få, kunne man tage hensyn til:
\begin{itemize}
	\item Fælles navn på produkter
	\item Ofte købte produkttyper i bestemte butikker
	\item Prisklasse for ofte købte produkter
	\item Bestemte tidspunkter for køb af produkter
\end{itemize}
Der er altså forskellige kriterier, hvormed man kan definere nye tilbud ud fra tidligere køb. Der er i dette projekt valgt at fokusere på det første punkt. Nye tilbud bliver altså fundet ud fra en fælles titel på tidligere købte produkter.

\subsubsection{Planlægning af algoritmen}
Det blev valgt at titlen bruges til at foreslå nye tilbud, da man ud fra titlen i mange tilfælde kan generalisere en stor mængde varer og ud fra disse udtrække nogle nøgleord. Jo flere varer kunden køber, og sætter på indkøbslisten i systemet, jo mere præcist kan nøgleordene findes. Det vil sige at funktionen også bør sortere, så de nøgleord der forekommer flest gange bør foreslås før de andre. Derudover vil der komme rigtig mange nøgleord efter længere tids brug, da kunden over lang tid sandsynligvis har købt mange forskellige ting der tilsammen kan give rigtig mange nøgleord. Derfor er det blevet valgt at sætte en begrænsning på antallet af nøgleord. Der bliver foreslået tre tilbud for hver af de syv nøgleord der fremkommer flest gange.

For at generere nøgleordene er det nødvendigt at definere et nøgleord mere præcist. Et nøgleord bliver betragtet, som det længst mulige fælles stykke tekst for titlerne på to eller flere varer. Det vil sige at eksempelvis \gaas{skummetmælk} og \gaas{minimælk} vil give nøgleordet \gaas{mælk}. Ud fra denne definition er det nu muligt at finde nogle nøgleord, som det så senere er muligt at finde tilbud ud fra. Da definitionen af et nøgleord nu er på plads, er det muligt at lave pseudokoden for algoritmen til at analysere tilbud.
\begin{figure}[H]
\begin{algorithm}[H]
\TitleOfAlgo{FindTilbud}
\textbf{FindTilbud}(vare[] KøbteVarer)\;
ListeAfNøgleord\;
ReturListeAfTilbud\;
\For{\emph{int} i $\leftarrow$ 1 \emph{\KwTo} KøbteVarer.Count \emph{\textbf{step}} 1}{
	\For{\emph{int} j$\leftarrow$i+1 \emph{\KwTo} KøbteVarer.Count \emph{\textbf{step}} 1}{
		string LængsteNøgleord $\leftarrow$ FindLængsteNøgleord(KøbteVarer[i],KøbteVarer[j])\;
		\eIf{ListAfNøgleord.Contains(LængsteNøgleord) $\neq$ True}
		{
			ListAfNøgleord.Add(LængsteNøgleord)\;
			ListAfNøgleord.Find(LængsteNøgleord).Antal $\leftarrow$ KøbteVarer[i].Antal + KøbteVarer[j].Antal\;
		}
		{
			NetopTilføjetVare $\leftarrow$  ListAfNøgleord.Find(LængsteNøgleord)\;
			\If{NetopTilføjetVare.VareIkkeTilføjetFør(KøbteVarer[i])}
			{
				NetopTilføjetVare.Antal $\leftarrow$NetopTilføjetVare.Antal + KøbteVarer[i].Antal\;
			}

			\If{NetopTilføjetVare.VareIkkeTilføjetFør(KøbteVarer[j])}
			{
				NetopTilføjetVare.Antal $\leftarrow$NetopTilføjetVare.Antal + KøbteVarer[j].Antal\;
			}
		}	
	 }
 }
ListeAfNøgleord.SorterEfterAntal()\;
\For{\emph{int} i $\leftarrow$ 1 \emph{\KwTo} 7 \emph{\textbf{step}} 1}
{
	Søgeresultat $\leftarrow$ SøgEfterTilbud(ListeAfNøgleord[i])\;
	\For{\emph{int} j $\leftarrow$ 1 \emph{\KwTo} 3 \emph{\textbf{step}} 1}
	{
		ReturListeAfTilbud.Add(Søgeresultat[j])\;
	}
}

\textbf{return} ReturListeAfTilbud\;
\caption{Pseudokode over algoritmen til at finde tilbud ud fra tidligere købte varer.}
\label{alg:FindTilbud}

\end{algorithm}
\end{figure}

Ved Algoritme \ref{alg:FindTilbud} ses pseudokoden over algoritmen til at foreslå tilbud ud fra tidligere købte varer. Det er nu muligt med udgangspunkt i pseudokoden at skrive den egentlige algoritme. Pseudokoden bliver brugt til at skabe sig et overblik. Det er valgt at tilbudene præsenteres på næsten samme måde som ved søgning på tilbud, da det næsten er den samme handling i forhold til hvad brugeren kan se på brugergrænsefladen. Der søges efter tilbud ud fra ord, og man kan så vælge at tilføje dem til sin liste eller ej. De bagvedliggende funktioner i forhold til hvilke ord der skal søges på er selvfølgelig meget forskellige, men set fra brugerens synspunkt, vil det give konsistens hvis præsentationen er næsten ens.
Når listen bliver returneret vil den som standard være sorteret efter hvor mange gange nøgleordet blev fundet i tidligere købte varer, men det er muligt for brugeren at sortere efter andre kriterier som f.eks. mængdepris.