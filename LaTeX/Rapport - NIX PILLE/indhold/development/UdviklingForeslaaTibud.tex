\label{sec:udviklingforeslaatilbud}
\section{Foreslå tilbud}
Alle dele af metoderne bliver ikke gennemgået, men det er muligt at se hele programmet på den vedlagte DVD, se bilag \ref{chap:appDVD}. Der vil i dette afsnit blive beskrevet nogle forskellige udsnit af koden.
Selve metoden er delt ud i forskellige undermetoder, hvilket kan ses på Kodeudsnit \ref{lst:LavAnalyseKald}. Her ses selve hovedmetoden til at finde tilbud ud fra tidligere køb. Linje 4 henter alle brugerens allerede købte varer ind i en liste. Ud fra den liste genereres først et antal nøgleord i linje 14. Disse nøgleord tjekkes så for fejl, som f.eks. stavefejl mm., da længste fælles streng af to varer ikke nødvendigvis giver mening. Til sidst bliver der i linje 18 fundet tilbud på de nøgleord der er tilbage. 

Der er hovedsageligt brugt to klasser: \gaas{ListElementInfo} og \gaas{ResultatListenMedAntalChecker}, hvor ResultatListenMedAntalChecker arver fra ListElementInfo. ListElementInfo indeholder en overskrift samt et antal. ResultatListenMedAntalChecker inderholder udover de arvede attributter en liste af ListElementInfo, som bliver brugt til at holde styr på hvilke varer der har fået lagt sin værdi til objektets antal-tæller.

\kode{Metoden til at finde tilbud ud fra tidligere købte varer.}{LavAnalyseKald}{LavAnalyseKald.txt}

Under metoden HentNoegleOrd bliver alle varernes titler sammenlignet med hinanden, og ud fra dette tilføjes deres nøgleord til en liste af nøgleord, hvilket også kan ses på kodeudsnit \ref{lst:HentNoegleOrd}.

\kode{{Et udsnit af metoden HentNogleOrd, hvor alle varerne bliver sammenlignet med hinanden.}}{HentNoegleOrd}{HentNoegleOrd.txt}

Når HentNoegleOrd metoden kaldes, vil den længste fælles streng blive fundet. Denne metode bliver kaldt inde i metoden TilfoejNoegleordTilListe som kaldes på linje 6 i kodeudsnit \ref{lst:HentNoegleOrd}. Metoden til at finde længste fælles streng kaldes FindFaellesOrd, og kan ses på kodeudsnit \ref{lst:FindFaellesOrd}.

\kode{Metoden FindFaellesOrd finder den længste mulige fælles streng for to givne strenge.}{FindFaellesOrd}{FindFaellesOrd.txt}

På kodeudsnit \ref{lst:FindFaellesOrd} ses at metoden hovedsageligt er bygget op af to løkker på linje 7 og 8. Her bliver det sammenliget, om de to bogstaver der i det givne gennemløb er ens. Hvis de er ens, tjekkes hvor mange bogstaver frem de er ens, set på linje 13-16. Derefter sammenlignes det, om den fundne streng er længere end evt. tidligere fundne strenge på linje 18. Samtidig bliver der kørt en række valideringskriterier gennem metoden \gaas{TjekForStrengDelAfOrd}.
Når der, som set på kodeudsnit \ref{lst:LavAnalyseKald}, bliver kaldt \gaas{TjekNoegleOrdForFejl}, bliver der tjekket for stavefejl samt, sorteret alle nøgleord fra, der er under tre bogstaver. Stavefejlene bliver tjekket vha. NHunspell \citep{nhunspell}.
Når nøgleordet er fundet, skal de flettes ind i listen med de allerede eksisterende nøgleord. Med det menes, at der skal undersøges, om nøgleordet allerede er fundet ved en tidligere sammenligning. Hvis dette er tilfældet, skal nøgleordets antal lægges til det allerede eksisterende nøgleords antal. Antallet er hvor mange gange det enkelte nøgleord er fundet. Hvis det ikke eksisterer, skal dette nøgleord tilføjes til listen. Dette gøres ved at kalde metoden \gaas{FletMedEkstisterendeListHvisNoegleordFindes}.
Her vil den få listen med allerede fundne nøgleord, samt det nøgleord der skal tilføjes. Et udsnit af metoden kan ses på kodeudsnit \ref{lst:noegleord}.

\kode{Rekursiv metode til at indsætte et nøgleord i listen af nøgleord.}{noegleord}{binaer.txt}

Metoden set på kodeudsnit \ref{lst:noegleord}, skal indsætte et nøgleord i en liste af allerede fundne nøgleord. Først skal det tjekkes om det nøgleord man ønsker at tilføje, allerede eksisterer i listen. For at gøre dette kunne man kigge hele listen igennem, men dette er ineffektivt og langsomt, hvilket er imod kriterierne for dette produkt. Derfor er det valgt i stedet at vedligeholde listen, så den altid er sorteret alfabetisk, og dermed kan der laves binær søgning i stedet. Funktionen benytter princippet bag binær søgning ved at kalde sig selv rekursivt. Som det ses på linje 7 på kodeudsnit\ref{lst:noegleord} ses at midten af listen over de allerede kendte nøgleord findes. Herefter sammenlignes det midterste objekt i listen med det nøgleord der forsøges indsættes. Ud fra denne sammenligning kan man så finde ud af, om man har fundet et matchende nøgleord, om der skal ledes videre i den første del af listen over nøgleord, eller ledes videre i den sidste del af listen. Hvis man skal lede videre, kalder metoden sig selv igen, hvor begrænsningen på søgeområdet er tilpasset, som det fx bliver gjort på linje 15. Ved hjælp af denne søgemetode reduceres værst tænkelig tidskompleksitet (worst case run time) fra O(n) per indsættelse af nøgleord til O(log(n)), se \citep{IntroAlgo}. Når man ser det i forhold til antallet af gange denne metode bliver kørt, vil det være en klar forbedring, også i forhold til kriteriet om, at programmet skal være effektivt. Samtidig vil det mindske den tid det vil tage at hente siden, specielt på en evt. lidt langsom mobilforbindelse.
