\section{Code Generation}
\label{sec:codegeneration}
The idea by using a high-level language is that it should be easier and faster to write programs. But by using a high-level language or any other kind of language, a compiler is needed to produce object code that should result in a running program, if the code is without errors. This section will be about how the code generation is implemented in this project and will also describe the choices that have affected the code generator.

The code produced by the code generator will need to run on an Arduino platform before it satisfies the project formulation, hence that the target code should be runnable on the targeted platform.

Arduino's IDE makes changes to the original code to ensure that the C/C++ code is correct. After this it calls avr-gcc which complies C/C++ code to object files and links to the necessary libraries. The object files are then uploaded to the Arduino unit using AVRDUDE \citep{Buildproc}. AVRDUDE is a tool used to upload to an AVR micro-controller \citep{AVRDUDE}. For our code generator it would be the most correct way to implement these functions into the compiler itself, but because of other more critical tasks at hand these features have been substituted by using the Arduino IDE to compile and upload the C/C++ code to the Arduino board. Therefore the target code for our compiler should be Arduino C/C++ code after which we use Arduino IDE for further compilation and uploading.

\kode{Here, the function to generate parse trees can be seen.}{generatP}{generatParseTree.txt}

The code generation is done by using a visitor pattern to go through the parse tree provided by the generated lexer and parser. This is done by creating an "ANTLRfilestream" of the file that should be compiled. This ANTLRfilestream are then given as parameters for the lexer generation, which are then used to generate a token stream by using the CommonTokenStream constructor. ANTLRfilestream and CommonTokenStream are provided by the antlr-4.0-complete.jar which is a library provided by ANTLR at \citep{DownloadANTLR}. A parse tree is then generated by using a parser based on the token stream. This procedure has been made as a function that returns a parse tree of the type SPLADParser to make it easier to generate parse trees. This function can be seen in code example \ref{lst:generatP}.

Before any of the actual code generation can begin we have to check scope rules, see section \ref{sec:scopecheck}, and type check the program, see section \ref{sec:typecheck}. If any of the two checks returns any errors there will not be generated any code based on the idea that non-functional code is a waste of resources. The compiler then print these errors to the user as information regarding what did not go well during compilation. If the two checks do not result in any errors the compiler will generate code for the given program.

\kode{An example of how a visitor for at node is constructed.}{nodexp}{nodexp.txt}

The code generation uses a visitor pattern that extends the AbstractParseTreeVisitor which is provided by the ANTLR tool when generating the lexer and parser. By extending the AbstractParseTreeVisitor we only need to override the methods that we are interested in. The visitor is implemented as a class which we then create an object of. The tree traversing is started by using the objects visit method with the root node of the parse tree as parameter. This rode node then visits method corresponding to our BNF rules, see section \ref{sec:bnf}, this way the parse tree is traversed all the way through. Each visitor then generates corresponding code depending on the type of node that have been traversed, an example of this can be seen in code example \ref{lst:nodexp}. All the generated code is stored in StringBuffers which are used to write all the code to a file. To illustrate the structure of a node thoroughly, we will describe and show code of how we have implemented the type container, drink and how some standard functions are provided to the users.

\kode{Here the function for printing the content of a file can be seen.}{pcontent}{pcontent.txt}

Arduino uses a "setup" function for assigning values to global variables or starting modules like LCD or RFID. The "setup" function is called once before Arduino calls the "loop" function. The "loop" functions main purpose is to keep the program running. To provide some standard function for the users, it has been necessary to write these functions and stored them inside the compiler. The chosen stored method is a simple text file which can be opened and read from. To open and read files a simple function has been made which returns a string with the content of the file hence the name "PrintContentofFile". The function can be seen in code example \ref{lst:pcontent}. These additional functions are added to the "headerbuffer" StringBuffer before any of the users code. The translated user code is then added to the "headerbuffer" afterwards.

\kode{In this code example the creation and assigning to the container arrays can be seen}{container}{container.txt}

Special measurements was needed to implement our types drink and containers. To handle the type container a list of them is generated while visiting the parse tree. Two arrays of the types string and integer are then created based on the size of these lists and added to a "contentbuffer" of the type StringBuffer. The string array will contain the containers name and the integer array will contain the output pin, which the containers are associated with. The containers name and output pins are then added to the two arrays and stored in the "setupfirstbuffer". This can be seen in code example \ref{lst:container}.

\kode{In this example the code for handling normal declaration and declaration with inheritances can be seen.}{drinkdclup}{drinkdclup.txt}

The drink type is implemented in a similar way as the container. When a drink is declared the code generator will create an new object of the class "Drinks" for the global variable "drinkHolder". A drink can be declare normally or inherit a recipe from another drink, which the users then can alter to his liking. To consider these options we check if there are any "drinkstmts", if there are then no inheriting takes place and code generator goes through the "drinkstmts" to compose the recipe list. This recipe list is stored as a list of ingredients in "drinkHolder" which at the end of the "visitDrinkdcl" function is added to the global list of "Drinks". If there were no "drinkstmts", the code generator will look up the drink to inherit from in the global list of drinks. If the drink it is to inherit from exists it takes that drinks recipe and copies it into the new drinks "listofingredients". The code generator then goes through the "changedrinkstmts" and adds the new ingredients which are to be added or removed. "Drinkstmts" and "changedrinkstmts" are nodes that takes care of adding or removing ingredients from drinks. The difference between "drinkstmts" and "changedrinkstmts" is the context they are used in. "Drinkstmts" can only be used in a non-inheriting declaration while "changedrinkstmts" only works in declaration with inherits. This can be seen in code example \ref{lst:drinkdclup}.


\kode{In this example it can be seen how the code generator generates code for the two-dimensional array and assigns content to it.}{drinkdcldown}{drinkdcldown.txt}

After the code generator has composed the drink recipe it appends the code to a StringBuffer, "tempreturnstring", to declare a two-dimensional array of the type double, named after the drink. The sizes are the size of the list of ingredients in the drink and two. The is done so each ingredient has an reference to container arrays and an amount of the given ingredient. The locations 0,0 and 0,1 are reserved to hold the number of the given ingredients for the given drink. This is done so one of the pre-made functions, "pourDrink", can get the array size. The code generator then runs through the list of ingredients and appends code for assigning the array with the id of the ingredient container and the amount to the StringBuffer "setupfirstbuffer", this can be seen in code example \ref{lst:drinkdcldown}.

Lastly all the translated code is appended to "contentbuffer" which is used to store the translated program.