\subsection{Code Generation of SPLAD}

\label{sec:codegeneration}
The idea of using a high-level language is that it should be easier and faster to write programs. By using a high-level language or any other kind of language, a compiler is needed to produce object code, which should result in a running program, if the code is without errors. This section is about how the code generation is implemented in this project and describes the choices which have affected the code generator.

The code produced by the code generator will need to run on an Arduino platform before it satisfies the problem statement, hence that the target code should be runnable on the targeted platform.

Arduino's IDE calls avr-gcc which complies C/C++ code to object files and links to the necessary libraries. The object files are then uploaded to the Arduino unit using AVRDUDE \citep{Buildproc}. AVRDUDE is a tool used to upload to an AVR micro-controller \citep{AVRDUDE}. For our code generator it would be the most correct way to implement these functions into the compiler itself, but because of other, more critical tasks at hand, these features have been substituted by using the Arduino IDE to compile and upload the C/C++ code to the Arduino board. Therefore, the target code for our compiler should be Arduino C/C++ code after which the user uses the Arduino IDE for further compilation and uploading.

\kode{Here, the function to generate parse trees can be seen.}{generatP}{generatParseTree.txt}

The code generation is done by using a visitor pattern to traverse the parse tree provided by the generated lexer and parser. This is done by creating an "ANTLRfilestream" of the file that should be compiled. This "ANTLRfilestream" is then given as a parameter for the lexer generation, which are then used to generate a token stream by using the "CommonTokenStream" constructor. "ANTLRfilestream" and "CommonTokenStream" are provided by the "antlr-4.0-complete.jar" which is a library provided by ANTLR \citep{DownloadANTLR}. A parse tree is then generated by using a parser, based on the token stream. This series of steps have been made as a function which returns a parse tree of the type "SPLADParser" to make it easier to generate parse trees. This function can be seen on listing \ref{lst:generatP}.

Before any of the actual code generation can begin, we have to check scope rules, see section \ref{sec:scopecheck}, and type check the program, see section \ref{sec:typecheck}. If any of the two checks returns any errors there they will be printed to the user. 

\kode{An example of how a visitor for a node is constructed.}{nodexp}{nodexp.txt}

\begin{grammatik}{rootexample}{Grammar for roots.}
<roots> $\ra$ $\eps$
\alt <root> <roots>
\end{grammatik}

The code generation uses a visitor pattern that extends the "AbstractParseTreeVisitor" which is provided by the ANTLR tool when generating the lexer and parser. The visitor is implemented as a class which we then create an object of. The tree traversing is started by using the objects visit method with the root node of the parse tree as parameter. This rode node then visits method corresponding to our BNF rules, see section \ref{sec:bnf}, this way the parse tree is traversed all the way through. Each visitor then generates corresponding code depending on the type of node that has been traversed, an example of this can be seen on listing \ref{lst:nodexp}. The corresponding grammar for the "roots" node can be seen on grammar \ref{gra:rootexample}. All the generated code is stored in "StringBuffers" which are used to writing all the code to a file. To illustrate the structure of a node thoroughly, we will describe and show a code of how we have implemented the type "container" and "drink" and how some standard functions are provided to the users.

\kode{Here the function for appending the content of a file can be seen.}{pcontent}{pcontent.txt}

Arduino has a "setup" which will be executed at startup. We use it for assigning values to global variables or starting modules such as LCD or RFID. The "setup" function is called once before Arduino calls the "loop" function. The "loop" function is called continues by the Arduino. To provide some standard functions for the users, it has been necessary to write these resources and store them inside the compiler. The way to store it is a simple text file which can be opened and read. To open and read files a simple function has been made which returns a string with the content of the resource, hence the name "LoadContentOfResources". The function can be seen in code example \ref{lst:pcontent}. These additional functions are added to the "headerbuffer" StringBuffer before any of the user's code. The translated user code is then added to the "headerbuffer" afterwards.

\kode{In this code example the creation and assigning to the container arrays can be seen.}{container}{container.txt}

Special measurements were needed to implement the types "drink" and "container". To handle the type "container" a list of them is generated while visiting the parse tree. Two arrays of the types string and integer are then created, based on the size of these lists and added to a "contentbuffer" of the type "StringBuffer". The string array will contain the container's name and the integer array will contain the output pin, which the container's are associated with. The container's name and output pins are then added to the two arrays and stored in the "setupfirstbuffer". This can be seen in listing \ref{lst:container}.

\kode{In this example the code for handling normal declaration and declaration with inheritances can be seen.}{drinkdclup}{drinkdclup.txt}

The "drink" type is implemented in a similar way as the "container". When a drink is declared, the code generator will create a new object of the class "Drinks" for the global variable "drinkHolder". A drink can be declared normally or inherit a recipe from another drink, which the users then can alter to his liking. To consider these options we check if there are any "drinkstmts". If there are, then no inheriting takes place and the code generator goes through the "drinkstmts" to compose the recipe list. This recipe list is stored as a list of ingredients in "drinkHolder" which, at the end of the "visitDrinkdcl" function, is added to the global list of "Drinks". If there were no "drinkstmts", the code generator will look up the drink to inherit from in the global list of drinks. If the drink it is to inherit from exists, it takes that drinks' recipe and copies it into the new drinks "listofingredients". The code generator then goes through the "changedrinkstmts" and adds the new ingredients which are to be added or removed. "drinkstmts" and "changedrinkstmts" are nodes that takes care of adding or removing ingredients from drinks. The difference between "drinkstmts" and "changedrinkstmts" is the context they are used in. "drinkstmts" can only be used in a non-inheriting declaration while "changedrinkstmts" only works in declaration with inherits. This can be seen in listing \ref{lst:drinkdclup}.


\kode{In this example it can be seen how the code generator generates code for the two-dimensional array and assigns content to it.}{drinkdcldown}{drinkdcldown.txt}

After the code generator has composed the drink recipe it appends the code to a StringBuffer, "tempreturnstring", to declare a two-dimensional array of the type double, named after the drink. The sizes are the size of the list of ingredients in the drink and two. This is done. so each ingredient has a reference to container arrays and an amount of the given ingredient. The locations 0,0 and 0,1 are reserved to hold the number of the given ingredients for the given drink. This is done, so one of the pre-made functions, "pourDrink", can get the array size. The code generator then runs through the list of ingredients and appends code for assigning the array with the id of the ingredient container and the amount to the StringBuffer "setupfirstbuffer". This can be seen on listing \ref{lst:drinkdcldown}.

Lastly, all the translated code is appended to "contentbuffer" which is used to store the translated program.