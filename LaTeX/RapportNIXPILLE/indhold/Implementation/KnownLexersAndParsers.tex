\section{Known lexers and parsers}
\label{sec:KnownLexersAndParsers}

In this section some of the different lexers and parsers, that are available on the internet, will be described.

\subsection{Lexer}
These programs generate a lexical analyzer also known as a scanner, that turns code into tokens which a parser uses.

\subsubsection{Lex}
Files are divided into three sections separated by lines containing two percent signs. The first is the "definition section" this is where macros can be defined and where headerfiles are imported. The second is the "Rules section" where regular expressions are read in terms of C statements. The third is the "C code section" which contains C statements and functions that are copied verbatim to the generated source file. Lex is not open source, but there are versions of Lex that are open source such as Flex, Jflex and Jlex. \citep{Lex}

\subsubsection{Flex}
Alternativ to lex \citep{Flex}

An optional feature to flex is the REJECT macro, which enables non-linear performance that allows it to match extremely long tokens. The use of REJECT is discouraged by Flex manual and thus not enabled by default. 

The scanner flex generates does not by default allow reentrancy, which means that the program can not safely be interrupted and then resumed later on.

\subsubsection{Jflex}
Jflex is based on Flex that focuses on speed and full Unicode support. It can be used as a standalone tool or together with the LALR parser generators Cup and BYacc/J \citep{Jflex}

\subsubsection{Jlex}
Based on lex but used for java. \citep{Jlex}

\subsection{Parser}
Parsertools generates a parser, based on a formal grammar from a lexer, checks for correct syntax and builds a data structure (Often in the form of a parse tree, abstract syntax tree or other hierarchical structure). 

\subsubsection{Yacc}
Generates a LALR parser that checks the syntax based on an analytic grammar, written in a similar fashion to BNF. Requires an external lexical analyser, such as those generated by Lex or Flex. The output language is C. \citep{Yacc}

\subsubsection{Cup}
More or less like Yacc, output language is in java instead. \citep{CUP}

\subsection{Lexer and parser}
Combines the lexer and parser in one tool.

\subsubsection{SableCC}
Using the CFG(Context Free Grammar) written in Extented Backus-Naur Form SableCC generates a LALR(1) parser, the output languages are: C, C++, C\#, Java, OCaml, Python \citep{SableCC}.

\subsubsection{ANTLR}
\textit{ANother Tool for Language Recognition} uses the CFG(Context Free Grammar) written in Extented Backus-Naur Form to generate an LL(*) parser. It has a wide variety of output languages, including, C, C++ and Java.
ANTLR can also make a tree parsers and combined lexer-parsers. It can automatically generate abstract syntax trees with a parser. \citep{ANTLR} %Those abstract syntax trees can be further processed with a tree parsers.


\subsubsection{JavaCC}
Javacc generate a parser from a formal grammar written in EBNF notation. The output is Java source code. JavaCC generates top-down parsers, which limits it to the LL(k) class of grammars (in particular, left recursion cannot be used). JavaCC also generates lexical analyzers in a fashion similar to lex\citep{Javacc}. The tree builder that accompanies it, JJTree, constructs its trees from the bottom uplex\citep{JJTree}.


\subsection{Comparison table}
\begin{table}[H]
\begin{tabularx}{\textwidth}{|l|c|c|R|}
\hline
\textbf{Name} & \textbf{Parsing algorithm} & \textbf{Input notation} & \textbf{Output language}\\ \hline
Yacc & LALR(1) & YACC & C\\ \hline
Cup & LALR(1) & EBNF & java\\ \hline
SableCC & LALR(1) & EBNF & C, C++, C\#, java, OCaml, Python\\ \hline
ANTLR & LL(*) & EBNF & ActionScript, Ada95, C, C++, C\#, Java, JavaScript, Objective-C, Perl, Python, Ruby\\ \hline
JavaCC & LL(k) & EBNF & Java, C++(beta)\\ \hline
\end{tabularx}
\end{table}

%ret herfra og ned specielt godt
Based on the different lexers and parsers attributes, compared to the expectations of this project, it has been decided that ANTLR best fit the project. The reason behind this is that ANTLR uses the LL(*) parser algorithm, this fits the structure of the CFG grammar for this project. Furthermore ANTLR's output language can be in Java, C or C++, this makes it easier to work on an Arduino. Another possibility could be to write the lexer and parser by hand, but many typingerrors are avoided by using a tool like ANTLR. Futhermore, it is easier to maintain the lexer and parser with a tool. When the grammar is changed, you can just generate a new lexer and parser with the tool. It has therefore been decided to use ANTLR for generating the lexer and parser in this project.