\section{Code Generation}
\label{sec:theorycodegeneration}
Code generation is the last phase of a compiler. It is in this phase that the target code is generated. An overview of all the phases in a compiler can be seen in figure \ref{fig:OverviewCompiler2}.

\subsection{Theory of Code Generation}
Traditionally a compiler generates machine code targeted at a specific architecture. This means that machine code compiled for the Intel x86 architecture will not be able to run on a RISC\footnote{Reduced Instruction Set Computing \citep{CraftingACompiler}.} architecture. The reason why a program compiled for one architecture will not run on another architecture, is that each architecture has slight differences in the set of instructions. The first phase in the code generation is the instruction selection. Instruction selection is needed exactly because of these different instruction sets. Another thing the code generator must take into account, is the register allocation and code scheduling, which might be implemented differently on different architectures, hence the different instruction sets. It is also obvious that register allocation is not needed on a machine which has no registers. Here other techniques for storing intermediate values can be used, depending on what the specific architecture provides \citep{CraftingACompiler}.

Recall that the target code needs not be machine code or byte code. A compiler can be used to compile a high-level language to a lower-level language, which means that the target code for example can be C. The main task of a \emph{machine code} generator is to choose the right instructions, and to insert the right instructions at the right places, the latter is called the code scheduling. This task is important because some pieces of code might dependent on other pieces of code. The code generator can then place these pieces of code close together, so no very long jumps occur. Long jumps are more expensive than shorter jumps. The code scheduler uses various algorithms to ensure the best position, for a given piece of code. The algorithms include topological sort, and shortest path algorithms.

Depending on how the compiler is implemented, the code generator can generate code from a provided intermediate representation, which is supplied by a translator. This is typically used when the compiler also includes an optimizer, which optimizes the source program to obtain greater execution speed. If the compiler includes no optimizer, the code-generator can be implemented as a visitor, which traverses the decorated abstract syntax tree provided directly by the type checker.