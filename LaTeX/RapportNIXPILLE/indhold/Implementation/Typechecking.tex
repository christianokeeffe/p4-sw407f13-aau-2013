\subsection{Type Checking}
\label{sec:typecheck}
In this section it is described how we type-check the code using the visitor pattern generated by ANTLR.

\subsubsection{Tree Traversal}
To traverse our parse tree we override the base visitors and at each node we visit, we check which node to visit next. This is done with every node that follows it, until we reach a leaf. As we reach a node we isolate important key data such as variables, types and operators. These are bubbled up to the respective node where they are used. For instance a variable is sent up from a leaf node to the declaration node and paired with a type to see if they are of the same type.

When we meet a variable for the first time we store it along with its value using a memory construct called "variablememory". This allows us to replace the variable name with its value, or a value of the given type if it has not been assigned a value, see section \ref{sec:Variable} for the explanation of what this is used for. We also use a memory construct called "functionmemory" where we store our functions so we can easily call them later, see section \ref{sec:Function} for more regarding the class used in the memory function.

\subsubsection{Value}
We use a class called "Value" to be able to return almost any type of data through the visitor pattern.
\kode{The "Value" class.}{Value}{Value.txt}
The class, as can be seen on listing \ref{lst:Value}, allows us to write expressions such as "Value p = new Value(5)", thus we can return the value 5. This can also be used to combine different types and return them as a value. It is useful because we do not always know what type will be returned and this makes it possible to convert everything into the same type which we can evaluate later.
\kode{How to evaluate "Value".}{isType}{isType.txt}
When we evaluate the type value we use functions such as those seen on listing \ref{lst:isType} which return "true" or "false". In the code example we make use of regular expressions to determine if a value is an integer or a double, by looking at what it contains such as numbers and symbols in the defined order. We use similar expressions for each type that exists in the language.

\subsubsection{Function}
\label{sec:Function}
We have made a class "function" as seen on listing \ref{lst:Function} to make it easier to store the name, parameters and return value of a function. This is used to retrieve the specific data that we need. Every time a function is found, it is added to our function memory. This allows us to find it, when, for instance, the function is called later in the code. We can then check if the call has the right setup, simply by comparing the type and amount of parameters from our memory to the ones used in the call.
\kode{The class "function".}{Function}{Function.txt}
The code which the programmer writes is intended to be compiled to an Arduino platform and thus needs to have certain functions to work properly. These are the functions "pour" and "RFIDFound", and so we check if they are present. Some commands such as "LCDPrint" and "RFIDWrite" are predefined in SPLAD and can be used without a declaration, so we have also defined them in our language as seen on listing \ref{lst:LCDPrint}
\kode{Defining "LCDPrint".}{LCDPrint}{LCDPrint.txt}
We will not implement all Arduino functions because it would take too much time and effort, so we have decided to only implement the ones involved with the LCD and RFID and a couple of the most commonly used Arduino functions. Furthermore, we have defined our own functions such as seen on listing \ref{lst:PourDrink} so we can type check it.
\kode{Predefining function "PourDrink".}{PourDrink}{PourDrink.txt}

\subsubsection{Variable}
\label{sec:Variable}
We have made a "variable" class to make it easier to store and retrieve the necessary data, as it is put into "variablememory". This class can be seen on listing \ref{lst:Variable}. In this class we have added two boolean expressions to make it easier to handle constants and arrays. So, if we meet a constant or an array, we set the appropriate expression to true. This will allows us to make a simple check to see if it is allowed to assign a new value to the variable.
\kode{"Variable" class.}{Variable}{Variable.txt}

In SPLAD "INPUT" and "OUTPUT" would be seen as variables and by default be undefined, so we predefined them as seen on listing \ref{lst:OUTPUT}. This is also done for "A0" to "A5" since these are used when determining input and output for the Arduino board. We have defined them with the type "container", because a container can have one of these values as its output.
\kode{Predefining "OUTPUT".}{OUTPUT}{OUTPUT.txt}

When we make a declaration, we first find the ID and then the type of the ID. Then we visit the node "assign" that traverses the tree, all the way down to the factor node and returns the value.

\subsubsection{Drink}
Our special type "drink" has its own separate declaration method. The initial part can be seen on listing \ref{lst:DrinkDcl}. First we check if it is a new drink will or will not inherit from another drink. This is done by looking at how many IDs are present, if there are two, then it means that it will inherit from an existing drink. If there is only one ID, then that means a new drink will not inherit from another drink.
\kode{Declaration of "Drink".}{DrinkDcl}{DrinkDcl.txt}
Whether or not it inherits from an existing drink, the type checker needs to check if the expressions used in the body are valid containers. If any of the expressions are invalid then an error for the given drink will be added to the list of errors.

\subsubsection{Error Handling}
We have made an "error" class to notify the programmer of the mistakes the type checker has found while checking the program. When an error is encountered we send a number and some information to the "error" class as seen on listing \ref{lst:IntError}.
\kode{Int error.}{IntError}{IntError.txt}
Our "error" class contains a switch case. An excerpt of this can be seen on listing \ref{lst:Error}. The error found is saved in a list that will be shown, when all the nodes have been visited.
\kode{"Switch case" error handling.}{Error}{Error.txt}