\subsection{Informal Type Rules}
This section contains the type rules for the comparison operator. In the type rules, $E$ is an expression and $C$ is a statement.
\begin{itemize}
\item Type rule for \textbf{<, >, <=, >=}:

"$E_1$ (<, >, <=, >=) $E_2$" is type correct and of type boolean if $E_1$ and $E_2$ are type correct and of type integer or double.

\item Type rule for \textbf{!=, =}:

"$E_1$ (!=, =) $E_2$" is type correct and of type boolean if $E_1$ and $E_2$ are type correct and of type integer or double, or if $E_1$ and $E_2$ are of the same type of either char or string.

\item Type rule for \textbf{+, -, *}:

"$E_1$ (+, -, *) $E_2$" is type correct and of type integer or double if $E_1$ and $E_2$ are type correct and of type integer or double.

\item Type rule for \textbf{/}:

"$E_1$ (/) $E_2$" is type correct and of type double if $E_1$ and $E_2$ are type correct and of type integer or double and $E_2$ does not have the value of zero.

\item Type rule for \textbf{<--} (assign):

"$E_1$ <-- $E_2$" is type correct if $E_1$ and $E_2$ are of the same of type or if $E_1$ and $E_2$ is of type integer or double.

\item Type rule of 'while'-statement: 

"while $E$ begin $C$ end" is type correct if $E$ is of type boolean and $C$ is type correct.

\item Type rule of 'from to step'-statement: 

"from $E_1$ to $E_2$ step $E_3$ begin $C$ end" are type correct if $E_1$, $E_2$ and $E_3$ are type correct and of type integer, and $C$ is type correct.

\item This is the type rules for 'if'-statement:

"if($E$) begin $C$ end" is type correct if $E$ is type correct and of type boolean, and $C$ is type correct.

\item Here the type rules for switch/case will be described:

"switch ($E$) begin case $E_1$: $C_1$ break; ... case $E_n$: $C_n$ break; default: $C_d$ break; end" is type correct if $E$, $E_1$...$E_n$ are type correct and of type integer, bool, double, char or string and are of the same type, and $C_1$...$C_n$ and $C_d$ are type correct.
\end{itemize}