\subsection{Scope Rules}
\label{sec:scoperules}
The scope of a variable is the block of the program in which it is accessible. A variable is local to a block, if it is declared in that block. A variable is non-local to a block if it is not declared in that block, but is still visible in that block (ex. global variables) \citep{sebesta}.
The languages scope rules determine how a variable name is associated with a variable in a particular occurrence or when working with a functional language, it needs to know how a name is associated with an expression when a variable is declared in a program unit or block. When a variable is declared in a program unit or block it is local for that part. Then the non-local variables are visible within the program unit or block if they are not declared there. Lastly there are global variables these are a special category of non-local variables.

\subsubsection{Static Scope}
Static scoping method was introduced in ALGOL 60, which is the method of binding names to non-local variables. There are two categories of static-scoped languages. First one is which sub-programs can be nested, this creates nested static scopes. And the other is static scopes which is also created by sub-programs but nested scopes are created only by nested class definitions and blocks.

\subsubsubsection{Blocks}
Blocks are used to define new static scopes in many languages. The idea is that it allows a section of code to have its own local variables.

An example on the use of blocks can be seen in code example \ref{lst:BlockCode}. Before the block $\{ \}$ the variable $x$ is initialized and set to integer 5, in the block, $x$ is set to 10 and a extra variable $y$ is initialized and is set to integer 15, $y$ is only visible inside block, thereby it can not be call outside of the block, but after the block, $x$ still have the value 10 that was given inside the block.

\begin{code}{BlockCode}{a simple code with use of blocks}
\begin{lstlisting}
int x = 5
\{
    int y = 15
    x = 10
\} 
\end{lstlisting}
\end{code}

\subsubsection{Dynamic Scope}
With dynamic scope, the scope is determined at run time, because it is based on the calling sequence of sub-programs and not their spatial relationship to one another.

\subsubsection{Declaration Order}
The main thing about declaration order is how the data declarations are made, they can be before functions, like C89, before they are used, like C\#, or they can be anywhere in the code, like C99, C++, Java and JavaScript.

\subsubsection{Global Scope}
Some languages allow a program structure to be a sequence of function definitions, like C, C++, PHP. Definitions outside functions in a file creates global variables, which make it visible to those functions.

\subsubsection{The difference between dynamic and static scope}
To help better understand the difference between dynamic and static Scope a larger code example is being shown here \ref{lst:StaticDynamicScoping}.
\begin{code}{StaticDynamicScoping}{A simple code showing the difference between static and dynamic scoping. \citep{StaticvsDynamic}}
\begin{lstlisting}
int b = 5;
int foo()
{
	int a = b + 5;
	return a;
}

int bar()
{
	int b = 2;
	return foo();
}

int main()
{
	foo();
	bar();
	return 0;
}
\end{lstlisting}
\end{code}
The code \ref{lst:StaticDynamicScoping} will in both cases return 10 in the foo() function, but in bar() the result will differ. With static scoping the bar() function will return 10 because at compile time b was set to 5 while with dynamic scoping it will return 7 because at run time b is set to 2.

\subsection{Scoping In This Project}
In SPLAD static scoping is used. This means that scopes are computed at compile time, based on the program text input. The main reason for this, is that programs for the Arduino platform is mainly written in C, which also uses static scoping. This makes the compilation from SPLAD to C simpler for the compiler \citep{arduinobuild}. Static scoping means that a hierarchy of scopes are maintained during compilation. To determine the name of used variables, the compiler must first check if the variable is in the current scope. If it is, the value of the variable is found, and the compiler can proceed, else it must recursively search the scope hierarchy for the variable. When done, if the variable is still not found, the compiler returns an error, because an undeclared variable is used \citep{sebesta}.