\subsection{Scopecheck}
\label{sec:scopecheck}
In our project we have chosen to use static scoping. Because the program languages that is made in the project group is a imperative program languages, where it make more sense that it have static scoping, the programs for the Arduino platform use static scoping, se section % Scoping under Semantics
And static scoping are used by well use program languages like C, C\# and Java \citep{ProgrammingCommunityIndex}.
When a variable is used in SPLAD, the variable is needed to have been declared in the scope or in a outer scope and the variable need to be declared before it is use.

When scope checking is started, a lists called "scopecontrol" is made which can hold others lists. Each list in scopecontrol is a "scope". The scope lists are used to store variable names. An example of this setup can be seen on figure \ref{fig:scopediagram}. To show the errors that are relate to scoping that are in the code, will be save into a list that is called "listOfErrors". Scope checking is break up in six different places in the tree visitor: visitProgram, visitBlock, visitSwitch, visitFunction, visitDcl, visitSubparams and visitCallid.

\begin{figure}[H]

\centering
\begin{tikzpicture}

\node [style=mynodestyle] (v1) at (0,2.5) {Scopcontrole};
\node [style=mynodestyle] (v2) at (-2,1) {Scope 1};
\node [style=mynodestyle] (v3) at (2,1) {Scope 2};
\node [style=mynodestyle] (v4) at (-3.5,-0.5) {Variable a};
\node [style=mynodestyle] (v5) at (-0.5,-0.5) {Variable b};
\node [style=mynodestyle] (v6) at (2,-0.5) {Varibale c};
\draw [-latex] (v1) edge (v2);
\draw [-latex] (v1) edge (v3);
\draw [-latex] (v2) edge (v4);
\draw [-latex] (v2) edge (v5);
\draw [-latex] (v3) edge (v6);
\end{tikzpicture}
\caption{A visual diagram of the structure of scopecontrol}
\label{fig:scopediagram}
\end{figure}

For making sure that global variables is saved into scopecontrol a global scope is needed to be made in visitProgram. This scope will be removed when we are finished with visiting the program.
\fxfatal{indsæt kodeeksempel her}

There are a three ways to make blocks in our project languages, not counting the one that make the global scope. First one is in visitBlock, one get to visitBlock from if, while and fromStatement. In visitBlock a new list of strings is made and then added to scopecontrol. Thereafter all statements in the block is visited. When this is done it will remove the list that it have made from scopecontrol and return.
\fxfatal{Hvad med blocken ved switch?}
\fxfatal{Indsæt kodeeksempel}

The second way to make new blocks is by making a function, and thereby visit the visitor visitFunction. A function name is not taken care of in the scope checker, because a function can only be declared in the outer scope. The visitBlock cannot be used to make scopes for functions, since there can be sent parameters to the function from where it is called. It must therefore make the list and add it to scopecontrol before the parameter are declared. After the parameters are declared, all statements in the function will be visited and it will then remove the list from scopecontrol before returning.

The third way to make new blocks is then visitSwitch is being use. In this case there is a new scope for each case that are in the switch

VisitDcl and visitSubparams is where variables names is inserted into the innermost scope, that have the last index in scopecontrol and is a list of strings.

The main part of scope checker is in visitCallid. Here it needs to look through all known scopes to see if a variable name exist. This is done by using two for-loops, which can be seen in code example \ref{lst:scopecallid}. The first one goes through scopecontrol and the second one is for each element in the list that are in scopecontrol. In this for-loops there is a if-statement that look for the variable name that is being called at the moment with the lists variable names. If it is in a list it will return from the visitCallid, but if it is not found in the lists it will put into the list "listOfErrors" and return from visitCallid.

\kode{scopecallid}{code snippet of where the name of a variable is look through all scopes}{scopecallid.txt}

After the scopecheck is done, it will print all the errors in the list of errors.
