For a compiler to able to distinguish between variables names and types the compiler will need some rules to describe the difference between them. This is done by reserving the words, so called keywords, that are used to describe types, the beginnings and endings of blocks and declaration of statements. A variable may not be named the same as any of the keywords since the compiler can not distinguish if it is a variable name or a reserved keyword.

To described the reserved keywords in the SPLAT language, the reserved keywords are listed see listing \ref{ReservedWords}.
\subsection{Reserved Keywords}
\begin{itemize}
\label{lst:ReservedWords}
\item bool
\item int
\item double
\item char
\item string
\item OR
\item AND
\item true
\item false
\item begin
\item end
\item if
\item else
\item function
\item using
\item return
\item nothing
\item switch
\item case
\item break
\item default
\item from
\item to
\item step
\item while
\item container

\end{itemize}
This listing is used to keep track of which words that are going to be reserved and that way give an overview for the programmer which words they may not use as names for their variables or functions. 

\subsection{Token Specification}
A parser needs a stream of token to parse a program correctly. These tokens are generated by a Lexer that reads a stream of input symbols and from a given set of rules, makes the corresponding tokens. A token specification is used to describe these rules the Lexer need in the construction of tokens. Token specification are expressed by regular expressions

\begin{tabular}{l l}
Terminal & Regular Expression \\ \hline
bool & "bool" \\
int & "int" \\
double & "double"\\
char & "char" \\
string & "string" \\
== & "$<--$" \\ 
|| & "OR" \\
\&\& & "AND" \\
< & "<" \\
> & ">" \\
<= & "<=" \\
>= & ">=" \\
!= & "!=" \\
= & "=" \\ 
$\{$ & "begin"\\
$\}$ & "end"\\
if & "if" \\
else & "else" \\
yy xx(zz) & "function xx returns yy using zz" \\
void & "nothing" \\
switch & "switch" \\
case & "case" \\
break & "break" \\
default & "default" \\
$for(i=xx; i<=yy; xx+=zz)$ & "from xx to yy step zz" \\
while & "while" \\
digitalWrite & "container" \\
m digit & $[0-9]^+$ \\
numeric & $ [0-9]^+ .[0-9]^+$ \\
id & $[A-Za-z] \circ ([A-Za-z]\cup [0-9])^*$ \\
boolean & $[true] \cup [false] $ \\
\end{tabular}