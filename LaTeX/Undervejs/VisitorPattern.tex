\subsection{Visitor pattern}
\label{sec:VisitorPattern}
Visitor pattern is for traversing an AST or a parse tree during the semantic analysis and code generation, to help manage the large number of phase and node interactions. A phase is traversed by writing \textit{visit} method in the phase's class, to reach every node there must be a \textit{visit} in the preceding node.

Here is an example of what a \textit{Generic visit} looks like:

\begin{code}{GenericVisitor}{A generic Visitor}
\begin{lstlisting}
\textbf{class} \textit{Visitor}
	\textbf{procedure} visit(\textit{AbstractNode n})
		\textit{n}.Accept(\textbf{this})
	\textbf{end}
\textbf{end}
\end{lstlisting}
\end{code}

Single dispatch is used by most object-oriented languages to determine which $visit$ must be used. The method is based on the type of the object $f$. But there are a few problems with single dispatch, such as that it finds a match based on the declared type of its parameters when it is called. This is where the visitor pattern comes in with a form of double dispatch, the idea is to make use of the abstract class that all nodes implement. But if the visit method is called as it is, it will try to visit the abstract node. For example if a phase contained a method $visit(IfNode$ $n)$, it will not invoked the actual $IfNode$, this is because the supplied parameter is based on the declared type $(AbstractNode)$. Therefore the specific node accepts a visitor and thus determines the type of the node which allows it to be visited because it now knows the actual $IfNode$ and the code it contains can be executed.