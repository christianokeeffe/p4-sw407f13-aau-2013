\section{Code Generation}
The idea by using a high-level language is that it should be easier and faster to write programs. But by using a high-level language or any other kind of language, a compiler is needed to produce object code that, if the code is without errors, should result in a running program. This section will be about how the code generation is implemented in this project and will also describe the choices that have affected the code generator.

The code produced by the code generator will need to run on an Arduino platform before it satisfies the project formulation, hence that the target code should be runnable on the targeted platform. Arduino's IDE make transformation to the code to make sure that it is correct c/c++ code. After this it calls the avr-gcc which complies c/c++ code to object files, which are then uploaded to the Arduino unit using the AVRDUDE \fxfatal{http://arduino.cc/en/Hacking/BuildProcess}. AVRDUDE is a tool for uploading to an AVR micro-controller \fxfatal{http://www.nongnu.org/avrdude/}.

For our code generator it would be the must correct way to implement these function into the compiler itself, but because of other more critical task at hard these features have been substituted by using the Arduino IDE to compile the c/c++ code and uploading this code to the Arduino board. Therefore the target code for our compiler should be the Arduino c/c++ code which we then uses the Arduino IDE for further compilation and uploading.

The code generation is done by using visitor pattern to go through the parse tree provided by the generated Lexer and Parser. This is done by creating an ANTLRfilestream of the file that should be compiled. This ANTLRfilestream are then given to as parameters for the Lexer generation, which are then used to generate a token stream by using the CommonTokenStream constructor. ANTLRfilestream and CommonTokenStream are provided by the antlr-4.0-complete.jar which are a library provided by ANTLR at \fxfatal{http://www.antlr.org/download.html}. A parse tree are then generated by creating a parser based on the token stream. This procedure have been made as a function that returns parse tree of the type SPLADParser to make it easier to generate parse trees. This function can seen on code example \fxfatal{tsk tsk tsk, lav kode udklip samt ref til den, funktionen hedder generateParseTree og er i main}.

Before any of the actual code generation can begin we have to check scope rules, see section \fxfatal{lav ref til scope rules afsnittet}, and type check the program, see section \fxfatal{lav ref til type check afsnittet}. If any of the two checks returns any errors there will not be generated any code based on the idea that non-functional code is a waste of resources. The compiler then print these errors to the user as information regarding what did not went well under compilation. If the two checks does not result in any errors the compiler will generated code for the given program.

The code generation uses a visitor pattern that extends the basevisitor which are provided by the ANTLR tool when generating the Lexer and Parser. By extending the basevisitor we only need to override the methods that we are interested in. The visitor is implemented as a class which we then create an object of. The tree traversing is started by using the objects visit method with the root node of the parse tree as parameter. This rode node then have visits method corresponding to the tree nodes that should be visit, this way the parse tree is traversed all the way through. Each visitor then generates corresponding code depending on the type of node that have been traversed, an example of this can be seen on code example \fxfatal{tsk, tsk, lav kode snippet af en node}. All the generated code are stored in StringBuffers which are used to write all the code to a file.

Arduino uses a setup function for assigning values to global variables or starting modules like LCD or RFID. The setup function is called once before Arduino calls the loop function. The loop functions main purpose is to keep the program running. To provide some standard function for the users, it has been necessary to write these provided functions and stored them inside the compiler. The chosen stored method is a simple text file which can open and read from. To open and read files a simple function have been made which returns a string, the content of the file hence the name of the function. The PrintContentofFile function can be seen on code example \fxfatal{lav kode udsnit til PrintContentofFile}. These additional functions are added to the headerbuffer StringBuffer before any of the users code. The users code then is added to the headerbuffer.

Special measurements was needed to implement our type drink and containers. To handle the type container a list of them is generated while visiting the parse tree. Two arrays of the types string and int are then created based on the size of these list and added to a contentbuffer of the type StringBuffer. The string array will contain the containers name and the int array will contain the output pin the containers are associate with. The containers name and out pin are then added to the two arrays and stored in the setupfirstbuffer. This can be seen on code example \fxfatal{lav kode ting til visit program med container arraiesne}.

The drink type is implemented in a similar way as the container. When a drink is declared the code generator will create an new object of the class Drinks for the global variable drinkHolder.
