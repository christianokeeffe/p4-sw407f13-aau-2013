\section{Choice of grammar}
The programmer, using this projects language, could be a hobby programmer, who would want to make a drink machine, but does not possess a high level of education in programming. Therefore it was decided that the grammar should have a high level of readability because this will ensure that it is easier for the person to read and understand their program - also useful if the code has to be edited later on. This on the other hand can decrease the level of write-ability because it has to be written in a specific way and will need to contain some extra words or symbols to mimic a human language rather than a computer language.


The method to assign a value to a variable is by typing "$variable$ <-- $value to assign$" this approach have been chosen, instead of the more commonly used "$=$" symbol, because a person not accustomed to programming might confuse which side of the "$=$" is assigned to the other. Thus by using the arrow, it is more clearly indicated that the value is assigned to the variable, and therefore ensuring readability - especially for the hobby programmer.

To get a more symmetrical structure in the code the functions must always return something, but it can return the value "nothing". This will ensure a better understanding and readability of the code when the programmer can see what it returns, even if no value is parsed. To indicate that $return$ is the last thing that will be executed in a function, the $return$ must always be at the end the function. To indicate that a program is called "call $functionname$" must be written.
There are used words instead of symbols (compared to most other programming languages), where suitable, to improve the understanding of the program.
"begin" and "end" are used to indicate a block (eg. an if statement). To combine logical operators the words "AND" and "OR" are used. The ";" symbol is used to improve readability by making it easier to see when the end of a line has been reached.

It would be appropriate to design a grammar that is a subset of $LL(1)$ grammars. This is based on the idea that it easier to implement a parser for $LL(1)$ grammars by hand compared to $LR$ grammars. This approach means it would be possible to both implement a parser by hand or use some of the already existing tools. This way both approaches are possible which are a suited solution for the project because it allows the project group to later go back and make the parser by hand instead of using a tool if that was the intention.

If the purpose was to create an efficient compiler it would be more appropriate to design the grammar as a subset of the $LALR$ grammar class. A parser for $LALR$ is balanced between power and efficiency which makes it more attractive than $LL$ and other $LR$ grammars, see section \ref{sec:grammar} for more on the grammars. $LR$ parsers can be made by hand but it is much more difficult than the $LL$ parsers.