\section{Choice of grammar}
When designing a language certain criteria should be kept in mind:
\begin{itemize}
\item Readability
- How easy it is to understand and comprehend a computation
\item Write-ability
- How easy it is for the programmer to write a computation clearly, correctly, concisely and quickly. 
\item Reliability
- Assures a program behaves the way it is suppose to.
\item Orthogonality
- A relatively small set of primitive constructs can be combined legally in relatively small number of ways.
\item Uniformity
- If some features are similar they should look and behave similar.
\item Maintainability
- Errors can be found and corrected and new features can be added easily.
\item Generality
- Avoid special cases in the availability or use of constructs and by combining closely related constructs into a single more general one	
\item Extensibility
- Provide some general mechanism for the programmer to add new constructs to a language.
\item Standardability
- Allow programs to be transported from one computer to another without significant change in language structure.
\item Implementability
- Ensure a translator or interpreter can be written
\end{itemize}

The programmer, using this projects language, could be a hobby programmer, who would want to make a drink machine, but does not possess a high level of education in programming. Therefore it was decided that the grammar should have a high level of readability because this will ensure that it is easier for the person to read and understand their program - also useful if the code has to be edited later on.


The method to assign a value to a variable is by typing "$variable$ <-- $value to assign$" this approach have been chosen, instead of the more commonly used "$=$" symbol, because a person not accustomed to programming might confuse which side of the "$=$" is assigned to the other. Thus by using the arrow, it is more clearly indicated that the value is assigned to the variable, and therefore ensuring readability - especially for the hobby programmer.

To get a more symmetrical structure in the code the functions must always return something, but it can return the value "nothing". This will ensure a better understanding and readability of the code when the programmer can see what it returns, even if no value is parsed. To indicate that $return$ is the last thing that will be executed in a function, the $return$ must always be at the end the function. To indicate that a program is called "call $functionname$" must be written.
There are used words instead of symbols (compared to most other programming languages), where suitable, to improve the understanding of the program.
"begin" and "end" are used to indicate a block (eg. an if statement). To combine logical operators the words "AND" and "OR" are used. The ";" symbol is used to improve readability by making it easier to see when the end of a line has been reached.

It would be appropriate to design a grammar that is a subset of $LL(1)$ grammars. This is based on the idea that it easier to implement a parser for $LL(1)$ grammars by hand compared to $LR$ grammars. This approach means it would be possible to both implement a parser by hand or use some of the already existing tools. This way both approaches are possible which are a suited solution for the project because it allows the project group to later go back and make the parser by hand instead of using a tool if that was the intention.

If the purpose was to create an efficient compiler it would be more appropriate to design the grammar as a subset of the $LALR$ grammar class. A parser for $LALR$ is balanced between power and efficiency which makes it more attractive than $LL$ and other $LR$ grammars, see section \ref{sec:grammar} for more on the grammars. $LR$ parsers can be made by hand but it is much more difficult than the $LL$ parsers.