\section{Type checking}
In this section we will describe how we type check code using the visitor pattern from the pretty printer \fxfatal{ref mangler}.

\subsection*{Value}
We use a class called "Value" to be able to return almost any type of data through the visitor pattern.
\kode{Value type}{Value}{Value.txt}
This class as can be seen on listing \ref{lst:Value} allows us to write "Value p = new Value(5)" thus we can return the value 5 up our tree. This can also be used to combine different types and return them as a value. This is useful because we do not always know what type will be returned and this makes it possible to convert everything into the same type which we can evaluate later.
\kode{How to evaluate Value}{isType}{isType.txt}
When we evaluate the type value we use functions like those seen on listing \ref{lst:isType} which returns "true" or "false". In the code example we make use of regular expressions to determine if it is an int or double by looking at what it contains like numbers and symbols in the defined order. We use similar functions for each other type we have in the language.

\subsection*{Functions}
We have made a class functions as seen on listing \ref{lst:Function} to make it easier to store the name, parameters and return value of a function so we  later can retrieve the specific data that we need. Every time a function is found it is added to our function memory. This allows us to find it when for instance the function is called later in code and thus we can see if the call have the right setup simply by comparing the amount and type of parameters from our memory to the ones that are being used in the call.
\kode{Function class}{Function}{Function.txt}
The code that programmer writes is intended to be compiled to an Arduino platform and thus needs to have certain functions to work properly, such as a function "setup" and "loop" and so we check if they are present. Some commands like LCDPrint and RFIDWrite are predefined in the Arduino language and can be used without a declaration, so we have also defined them in our language like seen on listing \ref{lst:LCDPrint}
\kode{Defining LCDPrint}{LCDPrint}{LCDPrint.txt}
We will not implement all Arduino functions because it would take too much time and effort, so we have decided to only take the ones involved with the LCD and RFID. Furthermore we have defined our own function \ref{lst:PourDrink} so we can type check it.
\kode{Predefining function PourDrink}{PourDrink}{PourDrink.txt}

\subsection*{Variables}
In our language "INPUT" and "OUTPUT" would be seen as variables and by default be undefined so we predefined them like seen on listing \ref{lst:OUTPUT}. This is also done for "A0" to "A5" since these are used when determining input and output for the Arduino board, we have defined them with the type "container" because a container can have one of these values as its output.
\kode{Predefining OUTPUT}{OUTPUT}{OUTPUT.txt}
We have made a variable class to be make it easier to store and retrieve the necessary data. This class be seen on listing \ref{lst:Variable}. In the class we have added two boolean expressions to make it easier handle constants and arrays, so if we meet a constant or an array we set the appropriate expression to true this allows us to make a simple check to see if you can assign a new value to the variable.
\kode{Variable class}{Variable}{Variable.txt}
When we make a declaration we first find the ID and the IDs type, then we visit the node assign that traverses the tree all the way down to the factor node%factor

\subsubsection*{drink}
Our special type "drink" has its own separate declaration method the initial part can be seen listing \ref{lst:DrinkDcl} first we check if it is a new drink that will be made or if it is one that will be modified. This is done be looking at how many IDs are present, if there are two then it means that there will be made changes to an existing drink. If there is only one ID then that means a new drink will be made.
\kode{Drink declaration}{DrinkDcl}{DrinkDcl.txt}
Whether or not its a new drink or an existing that is being changed then the type checker needs to check if the expressions used in the body are valid containers if not then an error will be added to the list.

\subsection*{Error handling}
We have made an error class to notify the programmer of mistakes he might make when writing his code. When an error is encountered we send a number and an id to our error class as seen on listing \ref{lst:IntError}.
\kode{Int Error}{IntError}{IntError.txt}
Our error class contains a switch case an excerpt of this can be seen on listing \ref{lst:Error}. The error found is saved to a list that will be shown when all the nodes have been visited.
\kode{Switch case error handling}{Error}{Error.txt}