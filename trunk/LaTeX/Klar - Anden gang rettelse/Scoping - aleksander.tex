\subsection{Scope Checking}
\label{sec:scopecheck}
In our project we have decided to use static scoping. Because the program language made in the project group is a imperative, it makes more sense to use static scoping. The language for Arduino uses static scoping, see section \ref{sec:scoperules}. Static scoping are used by well known program languages like C, C\# and Java \citep{ProgrammingCommunityIndex}. When a variable is used in SPLAD, the variable will need to be declared in the scope or in an outer scope before it can be used.

When scope checking is started, a list called "scopecontrol" is made which can hold other lists. A list called "listOfErrors" is also created which holds the errors that are found. Each list in scopecontrol is a scope. The scope lists are used to store variable names in the given scopes. An example of this can be seen in figure \ref{fig:scopediagram}. To show the errors that are related to the scope checking, the errors will be saved in the list listOfErrors. Scope checking is split into nine different places in the parse tree visitors: visitProgram, visitBlock, visitCases, visitEndcase, visitFunction, visitDcl, visitSubparams and visitCallid.

\begin{figure}[H]

\centering
\begin{tikzpicture}

\node [style=mynodestyle] (v1) at (0,2.5) {Scopcontrole};
\node [style=mynodestyle] (v2) at (-2,1) {Scope 1};
\node [style=mynodestyle] (v3) at (2,1) {Scope 2};
\node [style=mynodestyle] (v4) at (-3.5,-0.5) {Variable a};
\node [style=mynodestyle] (v5) at (-0.5,-0.5) {Variable b};
\node [style=mynodestyle] (v6) at (2,-0.5) {Varibale c};
\draw [-latex] (v1) edge (v2);
\draw [-latex] (v1) edge (v3);
\draw [-latex] (v2) edge (v4);
\draw [-latex] (v2) edge (v5);
\draw [-latex] (v3) edge (v6);
\end{tikzpicture}
\caption{A visual diagram of the structure of scopecontrol.}
\label{fig:scopediagram}
\end{figure}

For making sure that global variables are saved in scopecontrol, a global scope is added to scopecontrol in the visitProgram function. The global scope is removed when we are done with visiting the program.

There are three ways of creating a scope in the SPLAD language, not counting the one that makes the global scope. The first way is through visitBlock function, which is visited through if, while and from statements. In visitBlock a new list of strings is made and then added to scopecontrol. Thereafter all statements in the block is visited. When all the statements are visited, the scope is removed from scopecontrol. An example of this can be seen in listing \ref{lst:visitBlock}.

\kode{Visitor for blocks with scope checking implemented.}{visitBlock}{visitBlock.txt}
%Du er kommet her til......
The second way to make new blocks is when making a function, and thereby visit the visitor visitFunction. A function name is not taken care of in the scope checker, because a function can only be declared in the outer scope. The visitBlock cannot be used to make scopes for functions, since there can be sent parameters to the function from where it is called. It must therefore make the list and add it to scopecontrol before the parameter are declared. After the parameters are declared, all statements in the function will be visited and it will then remove the list from scopecontrol before returning.

The third way to make new blocks is when a making a switch. It will visit visitCases and thereafter visitEndcase. In visitEndcase it can either make a new visitCases, make a break and make a default case and return. When making a default case in visitEndcase there is needed to make a scope and remove it again.


VisitDcl and visitSubparams is where variables names is inserted into the innermost scope, that have the last index in scopecontrol and is a list of strings. It can be seen in the code snippet \ref{gra:visitDCL} for VisitDcl.

\kode{visitDCL}{our visitor with scope check for  visitDCL}{visitDCL.txt}

The main part of scope checker is in visitCallid. Here it needs to look through all known scopes to see if a variable name exist. This is done by using two for-loops, which can be seen in code example \ref{lst:visitCallid}. The first one goes through scopecontrol and the second one is for each element in the list that are in scopecontrol. In this for-loops there is a if-statement that look for the variable name that is being called at the moment with the lists variable names. If it is in a list it will return from the visitCallid, but if it is not found in the lists it will put into the list "listOfErrors" and return from visitCallid.

\kode{visitCallid}{code snippet of where the name of a variable is look through all scopes}{scopecallid.txt}

After the scopecheck is done, it will print all the errors in the list of errors.
