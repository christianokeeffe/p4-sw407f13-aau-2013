\subsection{Scopecheck}
\label{sec:scopecheck}
In our project we have chosen to use static scoping. Because the program languages that is made in the project group is a imperative program languages, where it make more sense that it have static scoping, the programs for the Arduino platform use static scoping, se section \ref{sec:scoperules}
And static scoping are used by well use program languages like C, C\# and Java \citep{ProgrammingCommunityIndex}.
When a variable is used in SPLAD, the variable is needed to have been declared in the scope or in a outer scope and the variable need to be declared before it is use.

When scope checking is started, a lists called "scopecontrol" is made which can hold others lists and a lists called "listOfErrors" that is holds the errors that is found. Each list in scopecontrol is a "scope". The scope lists are used to store variable names. An example of this setup can be seen on figure \ref{fig:scopediagram}. To show the errors that are relate to scoping that are in the code, will be save into the list listOfErrors. Scope checking is break up in nine different places in the tree visitor: visitProgram, visitBlock, visitCases, visitBreakend, visitEndcase, visitFunction, visitDcl, visitSubparams and visitCallid.

\begin{figure}[H]

\centering
\begin{tikzpicture}

\node [style=mynodestyle] (v1) at (0,2.5) {Scopcontrole};
\node [style=mynodestyle] (v2) at (-2,1) {Scope 1};
\node [style=mynodestyle] (v3) at (2,1) {Scope 2};
\node [style=mynodestyle] (v4) at (-3.5,-0.5) {Variable a};
\node [style=mynodestyle] (v5) at (-0.5,-0.5) {Variable b};
\node [style=mynodestyle] (v6) at (2,-0.5) {Varibale c};
\draw [-latex] (v1) edge (v2);
\draw [-latex] (v1) edge (v3);
\draw [-latex] (v2) edge (v4);
\draw [-latex] (v2) edge (v5);
\draw [-latex] (v3) edge (v6);
\end{tikzpicture}
\caption{A visual diagram of the structure of scopecontrol}
\label{fig:scopediagram}
\end{figure}

For making sure that global variables is saved into scopecontrol a global scope is needed to be made in visitProgram. This scope will be removed when we are finished with visiting the program.

There are a three ways to make blocks in our project languages, not counting the one that make the global scope. First one is in visitBlock, one get to visitBlock from if, while and fromStatement. In visitBlock a new list of strings is made and then added to scopecontrol. Thereafter all statements in the block is visited. When this is done it will remove the list that it have made from scopecontrol and return. It can be seen in the code snippet \ref{gra:visitBlock}.

\kode{visitBlock}{our visitor with scope check for  blocks}{visitBlock.txt}

The second way to make new blocks is when making a function, and thereby visit the visitor visitFunction. A function name is not taken care of in the scope checker, because a function can only be declared in the outer scope. The visitBlock cannot be used to make scopes for functions, since there can be sent parameters to the function from where it is called. It must therefore make the list and add it to scopecontrol before the parameter are declared. After the parameters are declared, all statements in the function will be visited and it will then remove the list from scopecontrol before returning.

The third way to make new blocks is when a making a switch. It will visit visitCases and thereafter visitEndcase. In visitEndcase it can either make a new visitCases, make a break and visit visitBreakend or make a default case and return. When making a default case in visitEndcase there is needed to make a scope and remove it again. In visitBreakend there is made a default case too, but here it is after a break, and again there is made a scope for the default case.


VisitDcl and visitSubparams is where variables names is inserted into the innermost scope, that have the last index in scopecontrol and is a list of strings. It can be seen in the code snippet \ref{gra:visitBlock} for VisitDcl.

\kode{visitBlock}{our visitor with scope check for  visitDCL}{visitDCL.txt}

The main part of scope checker is in visitCallid. Here it needs to look through all known scopes to see if a variable name exist. This is done by using two for-loops, which can be seen in code example \ref{lst:scopecallid}. The first one goes through scopecontrol and the second one is for each element in the list that are in scopecontrol. In this for-loops there is a if-statement that look for the variable name that is being called at the moment with the lists variable names. If it is in a list it will return from the visitCallid, but if it is not found in the lists it will put into the list "listOfErrors" and return from visitCallid.

\kode{scopecallid}{code snippet of where the name of a variable is look through all scopes}{scopecallid.txt}

After the scopecheck is done, it will print all the errors in the list of errors.
