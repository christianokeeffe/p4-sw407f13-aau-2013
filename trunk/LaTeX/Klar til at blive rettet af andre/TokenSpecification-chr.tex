\subsection{Tokens}
For a compiler to able to distinguish between variables names and types the compiler will need some rules to describe the difference between them. This is done by reserving the words, called keywords, which are used to describe types, the beginnings and endings of blocks, and declaration of statements. A variable may not be named the same as any of the keywords since the compiler can not distinguish if it is a variable name or a reserved keyword.

\subsubsection{Reserved Keywords}
The reserved keywords for SPLAD can be seen on table \ref{tab:keywords}.

\begin{table}[H]
	\begin{tabular}{|l|}
		\hline
		bool 		\\ \hline
		int 		\\ \hline
		double		\\ \hline
		char 		\\ \hline
		string 		\\ \hline
		OR	 		\\ \hline
		AND 		\\ \hline
		true 		\\ \hline
		false 		\\ \hline
		begin 		\\ \hline
		end 		\\ \hline
		if	 		\\ \hline
		else 		\\ \hline
		function 	\\ \hline
		using 		\\ \hline
		return 		\\ \hline
		nothing 	\\ \hline
		switch 		\\ \hline
		case 		\\ \hline
		break 		\\ \hline
		default 	\\ \hline
		from 		\\ \hline
		to	 		\\ \hline
		step 		\\ \hline
		while 		\\ \hline
		container	\\ \hline
		HIGH 		\\ \hline
		LOW 		\\ \hline
	\end{tabular}
	\caption{The reserved keywords in SPLAD}
	\label{tab:keywords}
\end{table}

%ret herfra og ned

This list is used to keep track of which words are going to be reserved and in that way provide an overview for the programmer. 

\subsubsection{Token Specification}
A parser needs a stream of tokens to parse a program correctly. These tokens are generated by a lexer which reads a stream of input symbols and from a given set of rules, makes the corresponding tokens. A token specification is used to describe the rules the lexer need in the construction of tokens. Token specification are expressed in way related to regular expressions \citep{sebesta}. Regular expressions are strong in describing patterns which is the core of token production \citep{sipser}.

\begin{tabular}{l l}
%Terminal & Regular Expression \\ \hline
%bool & "bool" \\
%int & "int" \\
%double & "double"\\
%char & "char" \\
%string & "string" \\
%== & "$<--$" \\ 
%|| & "OR" \\
%\&\& & "AND" \\
%< & "<" \\
%> & ">" \\
%<= & "<=" \\
%>= & ">=" \\
%!= & "!=" \\
%= & "=" \\ 
%$\{$ & "begin"\\
%$\}$ & "end"\\
%if & "if" \\
%else & "else" \\
%yy xx(zz) & "function xx returns yy using zz" \\
%void & "nothing" \\
%switch & "switch" \\
%case & "case" \\
%break & "break" \\
%default & "default" \\
%$for(i=xx; i<=yy; xx+=zz)$ & "from xx to yy step zz" \\
%while & "while" \\
%digitalWrite & "container" \\
PRIMITIVETYPE & 'int' | 'double' | 'bool' | 'char' | 'container' | 'string' \\
DIGIT & $[0 - 9]^+$ \\
NOTZERODIGIT & $[1-9][0-9]^*$ \\
LETTER & $[A-Za-z]^+$\\
COMMENT & /* $\dots$ */ \\
WHITESPACE & \\r | \\n | \\t \\
OTHER & $\varepsilon$ \\
%boolean & $[true] \cup [false]$ \\
\end{tabular}

Further work would be making a lexer to generate a token for the parser. Another options was to find a suited tool for generating a lexer for the given rules. This is a valid option because making a lexer can be automated and therefore already exists a lot of good lexer generators that can be used, see section \ref{sec:KnownLexersAndParsers}.