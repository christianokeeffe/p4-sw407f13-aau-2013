\chapter{Binær søgning}
I projektets system bruges binær søgning til at vedligeholde en liste over emner som skal bruges til at foreslå tilbud. Beskrivelsen af metoden \gaas{foreslå tilbud} kan ses i afsnit \ref{sec:udviklingforeslaatilbud}. I hovedtræk tjekker metoden om et fundet nøgleord allerede eksisterer i en liste af fundne nøgleord. Hvis nøgleordet er i listen, bliver det pågældende nøgleords antal talt op. 

\section{Generelt om binær søgning}
Binær søgning er en rekursiv søgning, som søger efter et element i en sorteret liste af elementer. Algoritmen får en sorteret liste som input, samt et element der søges efter. Algoritmen tjekker så det midterste element i listen i forhold til det element som søges efter. Hvis det midterste element er større end det input elementet, så forkastes den højre side af listen samt det midterste element. Listen af elementer består nu af halvdelen-1 af den oprindelige liste. Derefter kaldes binær søgning igen, denne gang med den resterende liste samt det oprindelige input element. Algoritmen forsætter således med at halvere listen, indtil det søgte element er fundet. Binær søgning har en tidskompleksitet på O(log(n)), altså væsentligt hurtigere end at tjekke samtlige elementer i listen \citep{IntroAlgo}.

\section{Rekursiv algoritme}
En rekursiv algoritme fungerer ved at tage et problem, dele det op i mindre del-problemer af samme type som det oprindelige problem, og så kalde sig selv på del-problemerne. På et tidspunkt bliver del-problemerne en størrelse som bliver trivielle at løse. Derefter samles resultaterne af del-problemerne, og en løsning af det oprindeligt givne problem opstår. I den binære søgning, er problemet trivielt, løst når der kun eksisterer ét element i listen af elementer, som gives som input til algoritmen.

\section{Binær søgningsfordele}
En binær søgning er en rekursiv algoritme som hver gang den støder på et komplekst problem, deler det op i to ens delproblemer (deraf navnet binær), og kalder sig selv på de nye problemer. Et eksempel på dette kunne være at man prøver at finde positionen på et tal i en sorteret liste. Algoritmen deler listen op i to, og ved at se på start- og slutpunktet vælger den hvilken del-liste den skal fortsætte med. Fordelen ved en binær søgning er, at hver gang den kalder sig selv halveres problemområdet, altså det område som skal søges igennem, dette giver i længden en meget hurtigere søgning i forhold til f.eks en lineær søgning.

\section{Binær søgning sammenlignet på worstcase tidskompleksitet med andre søgninger}
På tabel \ref{tab:Alkosammenligning} ses en opsummering af forskellige søge-algoritmer, deres fordele, kendetegn og tidskompleksitet.

\begin{table}[H]
\centering

    \begin{tabularx}{\textwidth}{|R|R|R|R|R|}
	\hline
		Algoritme     	& Kendetegn		 											& Fordele			 					& Worstcase Tidskompleksitet
		\\ \hline
		Binær søgning 	& Halverer problemet hver gang								& Relativ hurtigt, simpel algoritme.	& O(log(n)) 
		\\ \hline
		Lineær søgning  & Undersøger hver element én for én							& Nem at forstå, nem at implementere    & O(n) 
		\\ \hline
		Linked list     & Indeholder pointere til forrige og evt. næste element.	& Man kan altid komme til næste element	& $\theta$(n) 
		\\ \hline
\end{tabularx}
	
\caption{Tabel med sammenligning af forskellige søgealgoritmer. Kilde: \citep{IntroAlgo}}
\label{tab:Alkosammenligning}
\end{table}

I dette projekts system er binær søgning blevet valgt for netop at gøre systemet hurtigere. Binær søgning kræver dog en sorteret liste, hvilket projektets binære søgning netop taget højde for. Når metoden søger efter et nøgleord, som ikke findes ved hjælp af binær søgning, indsættes det på den korrekte position. På den måde vedligeholder metoden hele tiden en sorteret liste af nøgleord.

\section{Projektets binære søgning}
Som tidligere beskrevet, bruges binær søgning i dette projekts system til at vedligeholde en liste af nøgleord, som bruges i funktionen \gaas{Foreslå tilbud}. Det overordnede problem var, at ud fra en række nøgleord, skulle der bestemmes hvilket nøgleord optræder flest gange, og derfor er det vigtigste. De vigtigste nøgleord bruges så til at foreslå tilbud til brugerne. Systemets algoritme fungerer overordnet således, at den får en liste med elementer, en start- og en slutposition, og et element som efterspørges, samt de to elementer som skal sammenlignes. Metoden sammenligner derpå det midterste element med det efterspurgte element, og finder ud af, om det er større, mindre eller lig med det midterste. Hvis det midterste element er lig med det efterspurgte, så er det efterspurgte element allerede i listen, og antallet tælles op. Det forespurgte element tilføjes derpå til en liste af allerede brugte elementer, og bliver dermed ikke tjekket igen. Hvis det midterste element er mindre end det forespurgte, forkastes det midterste element og alle elementer før det. Derefter kaldes metoden igen, med den nye liste og samme efterspurgte element. Det samme sker hvis det midterste element er større end det forespurgte, bortset fra at her er det midterste element samt alle elementer efter det midterste der forkastes. Hvis alle elementer er blevet tjekket igennem, og det forespurgte element ikke findes i listen, så tilføjes det til listen med nøgleord, og til listen med elementer som allerede er brugt. 