\label{chap:konklusion}
This chapter concludes the report, and contains a round up of the most important aspects of the project.
The problem statement was presented in section \ref{sec:problemstatement}, and is as follows: 
\begin{itemize}
	\item \textbf{How can a programming language be developed, which makes it suitable for the hobbyist programmer to program drinks machines based on Arduino platforms?}
\end{itemize}

To answer the problem statement, the SPLAD language was developed, which aims at being a programming language that less experienced- and hobbyist programmers could program in. The formal specification of SPLAD can be seen in chapter \ref{chap:lanspec}. SPLAD is an abstraction of the C/C++ like language, used for programming for Arduinos. The abstraction enables the programming of a drinks machine with less effort than if it was programmed directly in the Arduino language. This is discussed more thoroughly in \ref{chap:discussion}. The main focus of the problem statement is, how a programming language suitable for a novice programmer can be specified.

This has been done by only including simple constructs, and not support more writeable statements, such as "i++" instead of "i<-$\,$- i+1" or "?" instead of "if else". This was decided to heighten readability, at the expense of decreasing writeability. These decisions and the trade-offs between the different criteria can be seen in section \ref{sec:designcriteria}. Another design decision, made to heighten readability at the cost of writeability, was the assignment of values to variables. In SPLAD this is denoted by "x <-$\,$- 4", where most other programming languages simply allows "x = 4". This decision removes any doubt about what is assigned to what. These decisions make the SPLAD language more suitable for novice programmers.
Another part of developing a programming language, is making a compiler for the language. This process can be seen in chapter \ref{chap:implementation}. The parser and lexical analyzer of the SPLAD compiler is generated by ANTLR, which is a lexer and parser generator. The parser and lexer generate a parse tree, which is given to the type checker, which then traverses this tree and checks that the types fulfills the given rules for SPLAD. Lastly the code generator generates the target code, which can then be further compiled by the Arduino compiler. This answers the second sub-statement of the problem statement. Overall, it can be argued that the project gives a fulfilling answer to the problem stated in this project. 