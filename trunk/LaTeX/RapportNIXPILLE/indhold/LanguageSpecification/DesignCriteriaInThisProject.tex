\subsection{Design Criteria in this Project}
\label{sec:DesignCriteria}
To determine how a programming language should be syntactically described, the trade-offs of designing a programming language must be taken into account. The different characteristics of a programming language, that will be used to evaluate trade-offs can be seen on table \ref{tab:langCharacteristics}.
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|R|}
		\hline
		
		Readability				& How easy it is to understand and comprehend a computation 		\\ \hline
		Writability				& How easy it is for the programmer to write a computation clearly, correctly, concisely and quickly\\ \hline
		Reliability 			& Assures a program behaves the way it is suppose to do	\\ \hline
		Simplicity				& When a program e.g. has a small number of basic constructs, and it is simple in the way that it has only one way to 									accomplish a particular operation\\ \hline
		Orthogonality 			& A relatively small set of primitive constructs can be combined legally in a relatively small number of ways\\ \hline	
		Data type				& The presence of adequate facilities for defining data types and data structures.\\ \hline
		Syntax design			& The syntax, or form, of the elements of a language. E.g. special words like "while" and "if".\\ \hline
		Support for abstraction	& Abstraction means the ability to define and then use complicated structures or operations in ways that allow many of the 									details	to be ignored.\\ \hline
		Expressivity			& A language can refer to several different characteristics. It means that a language have a relatively convenient, rather 									than cumbersome, way of specifying computations.\\ \hline
		Type Checking			& Testing for type errors in a given program, either by the compiler or during program execution.\\ \hline
		Exception handling		& The ability of a program to intercept run-time errors, take corrective measures, and then continue.\\ \hline
		Restricted aliasing		& Aliasing is having two or more distinct names that can be used to	access the same memory cell.\\ \hline
		
%		Uniformity 			& If some features are similar they should look and behave similar	  \\ \hline
%		Maintainability 	& Errors can be found and corrected and new features can be added	  \\
%		~ 					& easily 															  \\ \hline
%		Generality 			& Avoid special cases in the availability or use of constructs and by \\ 
%		~ 					& combining closely related constructs into a single more general one \\ \hline
%		Extensibility 		& Provide some general mechanism for the programmer to 				  \\
%		~ 					& add new constructs to a language 									  \\ \hline
%		Standardability 	& Allow programs to be transported from one computer 				  \\
%		~ 					& to another without significant change in language structure 		  \\ \hline
%		Implementability	& Ensure a translator or interpreter can be written 				  \\ \hline
	\end{tabularx}
	\caption{Brief explanation of language characteristics \citep{sebesta}.}
	\label{tab:langCharacteristics}
\end{table}
These characteristics are used to evaluate the the trade-offs of programming language. An overview of these can be seen on table \ref{tab:langTradeOffs}.

\begin{table}[H]
	\begin{tabular}{l|c|c|c|}
\textbf{Characteristic}	& \rotatebox{90}{Readability} &\rotatebox{90}{Writability} & \rotatebox{90}{Reliability} \\ \hline
Simplicity 				& $\bullet{•}$	& $\bullet{•}$	& $\bullet{•}$ \\ \hline
Orthogonality			& $\bullet{•}$	& $\bullet{•}$	& $\bullet{•}$ \\ \hline
Data types 				& $\bullet{•}$	& $\bullet{•}$	& $\bullet{•}$ \\ \hline
Syntax design 			& $\bullet{•}$	& $\bullet{•}$	& $\bullet{•}$ \\ \hline
Support for abstraction	& ~ 			& $\bullet{•}$ 	& $\bullet{•}$ \\ \hline
Expressivity 			& ~ 			& $\bullet{•}$ 	& $\bullet{•}$ \\ \hline
Type checking 			& ~ 			& ~ 			& $\bullet{•}$ \\ \hline
Exception handling 		& ~ 			& ~ 			& $\bullet{•}$ \\ \hline
Restricted aliasing 	& ~ 			& ~ 			& $\bullet{•}$ \\ \hline
	\end{tabular}
	\caption{Overview of trade-offs \citep{sebesta}.}
	\label{tab:langTradeOffs}
\end{table}

In table \ref{tab:langTradeOffs} $\bullet$ means that the characteristic affects the feature of the programming language where the $\bullet$ is placed. If there is no $\bullet$ in front of a feature, it means that this particular characteristic is not affected by the feature. 

Based on these trade-offs, it is clear that having a simple programming language affects both readability, write-ability and reliability. 
This is because having a simple-to-understand language, might not make it very write-able, since code that are simple-to-understand could take longer to write. 
On the other hand, having a simple-to-write programming language, might not make it very readable. An example of this is the if-statement in C, which can be written both with the 'if'-keyword, or more compact. This can be seen by comparing listing \ref{lst:ifstmtnormal} with listing \ref{lst:ifstmtcompact}, which both yield the same result. It is then clear, that the compact if-statement might be faster to write, but slower to read and understand, and opposite with the if-statement.

\begin{code}{ifstmtnormal}{Simple example of if-statement in C using the 'if'-keyword.}
	\begin{lstlisting}
		if (x > y)
		{
    		res = 1;
		}
		else
		{
    		res = 0;
		}
	\end{lstlisting}
\end{code}

\begin{code}{ifstmtcompact}{Simple example of if-statement in C without using the 'if'-keyword.}
	\begin{lstlisting}
		res = x > y ? 1 : 0;
	\end{lstlisting}
\end{code}

When defining the syntax of a programming language, it should balance these characteristics to achieve the right amount of trade-offs for that particular language. For the language of this project, it is important that the language is simple to read and understand, because the target group is the hobbyist-programmer, who might not have much experience in programming.

\begin{table}[H]
	\begin{tabular}{l|c|}
\textbf{Characteristic} 		& \rotatebox{90}{Chosen focus for this project} \\ \hline
		Simplicity 				& high 		\\ \hline
		Orthogonality 			& medium 	\\ \hline
		Data types 				& low 		\\ \hline
		Syntax design 			& high 		\\ \hline
		Support for abstraction	& medium	\\ \hline
		Expressivity 			& low 		\\ \hline
		Type checking 			& high 		\\ \hline
		Exception handling 		& low 		\\ \hline
		Restricted aliasing 	& low 		\\ \hline
	\end{tabular}
	\caption{Overview of choice of focus.}
	\label{tab:choiceoffocus}
\end{table}
Table \ref{tab:choiceoffocus} shows what paradigms that is in the focus for the project. 
\begin{itemize}
\item \textbf{Simplicity:} The language of this project does not have multiple ways of doing the same simple instructions. This is to make writing code simpler for beginners. An example is that it is not possible to increase a variable by 1 by writing "A++;". Instead it has to be written as "A<--A+1;".

\item \textbf{Orthogonality:} The language of this project only has four primitive types, bool, double, int and char, and 2 special types, container and string. It is not possible to make classes or constructs, this is done to simplify types for beginners.

\item \textbf{Data types:} \fxfatal{regler ikke lavet endnu, eks. kan en bool skrives som bool A = true og/eller bool A = 1}

\item \textbf{Syntax design:} It is not possible to make classes in the language of this project but there is both "for" and "while" loops because they are relatively simple to use and understand for beginners. All functions and loops start with "begin" and end with "end" to make it clear where they start and end.

\item \textbf{Support for abstraction:} This is close to non-existent in the project languages, because to help beginners with using the language, a simple  type system is simpler to understand.

\item \textbf{Expressivity:} \fxfatal{ikke helt sikker på hvad vi har bestemt os for}

\item \textbf{Type checking:} Is a major part of the project. The type checking will be done on compile time rather then run time, to help beginners see their errors in their code, instead of at run time.

\item \textbf{Exception handling:} \fxfatal{ikke helt sikker på hvad vi har bestemt os for}

\item \textbf{Restricted aliasing:} Since it is known that using aliasing is a dangerous feature in a programming language \fxfatal{indsæt kilde her}, the language of this project will not have this feature, to help beginners.
\end{itemize}
