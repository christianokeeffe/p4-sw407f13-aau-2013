\subsection{Scope Rules}
The scope of a variable is the range of statements where variables are visible. The variable is visible if it can be referenced in the statement.
The languages scope rules determine how a variable name is associated with a variable in a particular occurrence or when working with a functional language, it needs to know how a name is associated with an expression when a variable is declared in a program unit or block. When a variable is declared in a program unit or block it is local for that part. Then the non-local variables are visible within the program unit or block if they are not declared there. Lastly there are global variables these are a special category of non-local variables.

\subsubsection{Static Scope}
Static scoping method was introduced in ALGOL 60, which is the method of binding names to non-local variables. There are two categories of static-scoped languages. First one is which sub-programs can be nested, this creates nested static scopes. And the other is static scopes which is also created by sub-programs but nested scopes are created only by nested class definitions and blocks.

\subsubsubsection{Blocks}
Blocks are used to define new static scopes in many languages. The idea is that it allows a section of code to have its own local variables.

An example on the use of blocks can be seen in code example \ref{lst:BlockCode}. Before the block $\{ \}$ the variable $x$ is initialized and set to integer 5, in the block, $x$ is set to 10 and a extra variable $y$ is initialized and is set to integer 15, $y$ is only visible inside block, thereby it can not be call outside of the block, but after the block, $x$ still have the value 10 that was given inside the block.

\begin{code}{BlockCode}{a simple code with use of blocks}
\begin{lstlisting}
int x = 5
\{
    int y = 15
    x = 10
\} 
\end{lstlisting}
\end{code}

\subsubsection{Dynamic Scope}
With dynamic scope, the scope is determined at run time, because it is based on the calling sequence of sub-programs and not their spatial relationship to one another.

\subsubsection{Declaration Order}
The main thing about declaration order is how the data declarations are made, they can be before functions, like C89, before they are used, like C\#, or they can be anywhere in the code, like C99, C++, Java and JavaScript.

\subsubsection{Global Scope}
Some languages allow a program structure to be a sequence of function definitions, like C, C++, PHP. Definitions outside functions in a file creates global variables, which make it visible to those functions.

\subsubsection{The difference between dynamic and static scope}
To help better understand the difference between dynamic and static Scope a larger code example is being shown here \ref{lst:StaticDynamicScoping}.
\begin{code}{StaticDynamicScoping}{A simple code showing the difference between static and dynamic scoping. \citep{StaticvsDynamic}}
\begin{lstlisting}
int b = 5;
int foo()
{
	int a = b + 5;
	return a;
}

int bar()
{
	int b = 2;
	return foo();
}

int main()
{
	foo();
	bar();
	return 0;
}
\end{lstlisting}
\end{code}
The code \ref{lst:StaticDynamicScoping} will in both cases return 10 in the foo() function, but in bar() the result will differ. With static scoping the bar() function will return 10 because at compile time b was set to 5 while with dynamic scoping it will return 7 because at run time b is set to 2.