\section{Code Generation}
The idea by using a high-level language is that it should be easier and faster to write programs. But by using a high-level language or any other kind of language, a compiler is needed to produce object code that, if the code is without errors, should result in a running program. This section will be about how the code generation is implemented in this project and will also describe the choices that have affected the code generator.

The code produced by the code generator will need to run on an Arduino platform before it satisfies the project formulation, hence that the target code should be runnable on the targeted platform.

Arduino's IDE makes transformation to the code to secure c/c++ code is correct. After this it calls avr-gcc which complies c/c++ code to object files and links to the necessary libraries. The object files are then uploaded to the Arduino unit using AVRDUDE \citep{Buildproc}. AVRDUDE is a tool for uploading to an AVR micro-controller \citep{AVRDUDE}. For our code generator it would be the must correct way to implement these function into the compiler itself, but because of other more critical task at hand these features have been substituted by using the Arduino IDE compiling and uploading the c/c++ code to the Arduino board. Therefore the target code for our compiler should be Arduino c/c++ code which we then uses Arduino IDE for further compilation and uploading.

The code generation is done by using a visitor pattern to go through the parse tree provided by the generated Lexer and Parser. This is done by creating an "ANTLRfilestream" of the file that should be compiled. This ANTLRfilestream are then given to as parameters for the Lexer generation, which are then used to generate a token stream by using the CommonTokenStream constructor. ANTLRfilestream and CommonTokenStream are provided by the antlr-4.0-complete.jar which are a library provided by ANTLR at \citep{DownloadANTLR}. A parse tree are then generated by creating a parser based on the token stream. This procedure have been made as a function that returns parse tree of the type SPLADParser to make it easier to generate parse trees. This function can seen on code example \fxfatal{tsk tsk tsk, lav kode udklip samt ref til den, funktionen hedder generateParseTree og er i main}.

Before any of the actual code generation can begin we have to check scope rules, see section \fxfatal{lav ref til scope rules afsnittet}, and type check the program, see section \fxfatal{lav ref til type check afsnittet}. If any of the two checks returns any errors there will not be generated any code based on the idea that non-functional code is a waste of resources. The compiler then print these errors to the user as information regarding what did not went well under compilation. If the two checks does not result in any errors the compiler will generated code for the given program.

The code generation uses a visitor pattern that extends the basevisitor which are provided by the ANTLR tool when generating the Lexer and Parser. By extending the basevisitor we only need to override the methods that we are interested in. The visitor is implemented as a class which we then create an object of. The tree traversing is started by using the objects visit method with the root node of the parse tree as parameter. This rode node then have visits method corresponding to our BNF rules, see section \fxfatal{lav ref til BNF'en} that should be visit, this way the parse tree is traversed all the way through. Each visitor then generates corresponding code depending on the type of node that have been traversed, an example of this can be seen on code example \fxfatal{tsk, tsk, lav kode snippet af en node}. All the generated code are stored in StringBuffers which are used to write all the code to a file. To illustrate the structure of a node thoroughly, we will describe and show code of how we have implemented the type container, drink and how some standard functions are provided to the users.

Arduino uses a "setup" function for assigning values to global variables or starting modules like LCD or RFID. The "setup" function is called once before Arduino calls the "loop" function. The "loop" functions main purpose is to keep the program running. To provide some standard function for the users, it has been necessary to write these functions and stored them inside the compiler. The chosen stored method is a simple text file which can open and read from. To open and read files a simple function have been made which returns a string, the content of the file hence the name of the function. The "PrintContentofFile" function can be seen on code example \fxfatal{lav kode udsnit til PrintContentofFile}. These additional functions are added to the "headerbuffer" StringBuffer before any of the users code. The translated user code are then added to the headerbuffer afterwards.

Special measurements was needed to implement our types drink and containers. To handle the type container a list of them is generated while visiting the parse tree. Two arrays of the types string and integer are then created based on the size of these list and added to a "contentbuffer" of the type StringBuffer. The string array will contain the containers name and the integer array will contain the output pin the containers are associate with. The containers name and output pins are then added to the two arrays and stored in the "setupfirstbuffer". This can be seen on code example \fxfatal{lav kode ting til visit program med container arraiesne}.

The drink type is implemented in a similar way as the container. When a drink is declared the code generator will create an new object of the class "Drinks" for the global variable "drinkHolder". A drink can be declare normally or by inheriting their recipe from another drink, which the users then can alternate to his likings. To consider these option we check if there are any "drinkstmts", if there are any of these "drinkstmts" no inheriting takes place and code generator goes through the "drinkstmts" to compose the recipe list. This recipe list is stored as a list of ingredients in "drinkHolder" which at the end of the "visitDrinkdcl" function is added to the global list of "Drinks". If there were not any "drinkstmts", the code generator will look up the drink to inherit from in the global list of drinks. If the drink it is to inherited from exists it takes that drinks recipe and copies that into the new drinks "listofingredients". The code generator then goes through the "changedrinkstmts" and adds the new ingredients which are to be added or removed. "Drinkstmts" and "changedrinkstmts" are nodes that takes care of adding or removing ingredients from drinks. The difference between "drinkstmts" and "changedrinkstmts" is the context they are used in. "Drinkstmts" can only be used in a non-inheriting declaration while "changedrinkstmts" only works in declaration with inherits. The "visitDrinkdcl" can be seen on code example \fxfatal{set kode udklip ind af drinkdcl}.

After the code generator have composed the drink recipe it appends the code to a stringbuffer, "tempreturnstring", to declare an two-dimensional array of the type double, named after the drink. The sizes are the size of the list of ingrediants in the drink and two. The is done so each ingredient has an reference to container arrays and a amount of the given ingrediant. The locations 0,0 and 0,1 is reserved to hold the number of the given ingredients for the given drink. This is done so one of the pre-made function, "pourDrink", can get the array size. The code generator then runs through the list of ingredients and appends code for assigning the array with the id of the ingredient container and the amount to the stringbuffer "setupfirstbuffer", this can be seen on code example \fxfata{lav kode ting til nedereste del af drinkdcl}.

Lastly all the translated code are appended to "contentbuffer" which are used to store the whole translated program.