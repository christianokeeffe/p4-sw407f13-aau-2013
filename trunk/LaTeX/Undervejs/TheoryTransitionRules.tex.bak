\input{../RapportNixPille/preamble}
\begin{document}
\section{Transition Rules}
In this section some of the transition rules in SPLAD will be explained. The complete list of all the rules can be seen in appendix \ref{sec:transitionrules}.
In the following text we use the following names to represent different syntactic categories.
\begin{itemize}
\item $n \in \textbf{Num}$ - Numerals
\item $x \in \textbf{Var}$ - Variables 
\item $r \in \textbf{Arrays}$ - Array names
\item $a \in \mathbf{A_{exp}}$ - Arithmetic expression
\item $b \in \mathbf{B_{exp}}$ - Boolean expression
\item $S \in \textbf{Stm}$ - Statements
\item $p, q \dots \in \textbf{Pnames}$ - Function names
\item $D_V \in \textbf{ErkV}$ - Variable declarations
\item $D_P \in \textbf{ErkP}$ - Function declarations
\item $D_A \in \textbf{ErkA}$ - Array declarations
\end{itemize}

\subsection{Abstract Syntax}
In order to describe the behavior of a program, er must first account for its syntax. We use the notion of abstract syntax, since it will allow us to describe the essential structure of the program. An abstract syntax is defined as follows. We assume a collection of syntactic categories and for each syntactic category we give a finite set of formation rules that define how the the inhabitants of the category can be build \citep{HHTree}.
Here the abstract syntax of SPLAD can be seen. 
\fxfatal{bla bla bla}
\begin{align*}
S::= \; & x := a \; | \; r[a_1] := a_2 \; | \; S_1; \; S_2 \; | \; \text{if} \; b \; \text{do} \; S \; | \; \text{if} \; b \; \text{do} \; S_1 \; \text{else do} \; S_2 \; | \; \text{while} \; b \; \text{do} \; S \\
~ & | \; \text{from} \; x := a_1 \; \text{to} \; a_2 \; \text{step} \; a_3 \; \text{do} \; S \; | \; \text{call} \; p(\vec{x}) \; | \; \text{begin} \; D_V \; D_P \; S \; \text{end} \\
a::= \; & n \; | \; x \; | \; a_1 + a_2 \; | \; a_1 - a_2 \; | \; a_1 * a_2 \; | \; a_1 / a_2 \; | \; (a) \; | \; r[a_i]\\
b::= \; &a_1 = a_2 \; | \; a_1 > a_2 \; | \; a_1 < a_2 \; | \; \neg b \; | \; b_1 \; \wedge \; b_2 \; | \; b_1 \; \vee \; b_2 \; | \; (b) \\
D_V::= \; & \text{var} \; x := a; \; D_V \; | \; \varepsilon \\
D_P::= \; & \text{func} \; p \; \text{is} \; S;\;  D_P \; | \; \varepsilon \\
D_A::= \; & \text{array} \; r[a_1]; \; D_A \; | \; \varepsilon \\
\end{align*}

\subsection{Transition Systems}


\subsection{Big-step-semantic and small-step-semantic}
\fxfatal{Forklar hvad det er, og at vi bruger big-step.}

\subsection{Environment-Store Model}
In our project we use the \textit{environment-store model} to represent how a variable is bound to a storage cell (called a \textit{location}), in the computer, and that the value of the variable is the content of the bound location. All the possible locations are denoted by \textbf{Loc} and a single location as $l \in \textbf{Loc}$. We assume all locations are integer, and therefore $\textbf{Loc} = \mathbb{Z}$. Since all locations are integers we can define a function to find the next location: $\textbf{Loc} \rightarrow \textbf{Loc}$, where $l = l + 1$. 

We define the set of stores to be the mappings from locations to values $\textbf{Sto } = \textbf{ Loc } \rightharpoonup \mathbb{Z}$, where $sto$ is an single element in $\textbf{Sto}$.

An variable-environment is like a symbol table containing each variable and store the variables address. The store then describe which values that is on each address.

The following names represent the different environments. 
\begin{itemize}
\item $env_V \in Env_V$ - Variable environment
\item $env_A \in Env_A$ - Array environment
\item $env_P \in Env_P$ - Procedure environment
\end{itemize}

\subsection{Statements}
The transition rules for the statements are on the form: $env_V, env_P \vdash \langle S, sto \rangle \rightarrow sto'$.

The transition rule for variable assignment in SPLAD can be seen on table \ref{tab:VarAssign}. When a variable is assigned the contents of $l$ is updated to $v$, where $l$ is the location of $x$ found in the $env_V$ and $v$ is the result of the arithmetic expression $a$.

\begin{longtable}{l l}
\longtablesetting{2}
[VAR-ASS] & $env_V, env_P \vdash \langle x <-- a, sto \rangle \rightarrow sto[l \mapsto v]$ \\
~ & ~ \\
~ & \indent\indent where $env_V, sto \vdash a \rightarrow_a v$ \\
~ & \indent\indent and $env_V \; x = l$ \\
~ & ~ \\
\caption{Transition rule for variable assignment.}
\label{tab:VarAssign}
\end{longtable}

\subsection{Arithmetic Expressions}
The transition rules for the arithmetic expressions are on the form: $env_V, sto \vdash a \rightarrow_a v$.

The transition rule for multiplication in SPLAD can be seen on table \ref{tab:MultExp}. The rule states, that if $a_1$ evaluates to $v_1$ and $a_2$ evaluates to $v_2$, using any of the rules from the arithmetic expressions, then $a_1 \cdot a_2$ evaluates to $v$ where $v = v_1 \cdot v_2$.

\begin{table}[!H]
\begin{tabular}{l l}
[MULT] & $\dfrac{env_V, sto \vdash a_1 \rightarrow_a v_1 \; \; \; env_V, sto \vdash a_2 \rightarrow_a v_2}{env_V, sto \vdash a_1 \cdot a_2 \rightarrow_a v}$ \\
~ & ~ \\
~ & \indent\indent where $v = v_1 \cdot v_2$ \\
~ & ~ \\
\end{tabular}
\caption{The transition rule for the arithmetic multiplication expression.}
\label{tab:MultExp}
\end{table}

\subsection{Boolean Expression}
The transition rules for boolean expressions are on the form: $env_V, sto \vdash b \rightarrow_b t$.

The transition rule for logical-or in SPLAD can be seen on table \ref{tab:OrExp}. The rules have two parts: [OR-TRUE] and [OR-FALSE]. The [OR-TRUE] rule states that either $b_1$ or $b_2$ evaluates to \textit{TRUE}, using any of the rules from the boolean expressions, then the expression $b_1 \; \text{OR} \; b_2$ evaluates to \textit{TRUE}. [OR-FALSE] states that if both $b_1$ and $b_2$ evaluate to \textit{FALSE} then the expression $b_1 \; \text{OR } \; b_2$ evaluates to \textit{FALSE}.

\begin{longtable}{l l}
\longtablesetting{2}
[OR-TRUE] & $\dfrac{env_V, sto \vdash b_i \rightarrow_b \text{TRUE}}{env_V, sto \vdash b_1 \vee b_2 \rightarrow_b \text{TRUE}}$ \\
~ & ~ \\
~ & \indent\indent where $i \in {1,2}$ \\
~ & ~ \\

[OR-FALSE] & $\dfrac{env_V, sto \vdash b_1 \rightarrow_b \text{FALSE} \; \; \; env_V, sto \vdash b_2 \rightarrow_b \text{FALSE}}{env_V, sto \vdash b_1 \vee b_2 \rightarrow_b \text{FALSE}}$ \\
~ & ~ \\
\caption{Transition rule for the boolean expression logical-or.}
\label{tab:OrExp}
\end{longtable}

\subsection{Variable Declaration}
The transition rules for the variable declarations are on the form: $\langle D_V, env_V, sto \rangle \rightarrow_{DV} (env_V', sto')$ and the configurations are defined by $\Gramma_{DV} = (\textbf{ErkV} \times \textbf{EnvV} \times \textbf{Sto}) \cup \textbf{EnvV \times \textbf{Sto}}$ and $\Tau_{DV} = \textbf{EnvV} \times \textbf{Sto}$.

On table \ref{tab:VarDecl} the transition rules for variable declaration can be seen.

\begin{longtable}{l l}
\longtablesetting{2}
[VAR-DEC] & $\dfrac{\langle D_V, env_V'', sto[l \mapsto v] \rangle \rightarrow_{DV} (env_V', sto'}{\text{var} \; x <-- a; D_V, env_V, sto \rangle \rightarrow_{DV} (env_V', sto')}$ \\
~ & ~ \\
~ & \indent\indent where $env_V, sto \vdash a \rightarrow_a v$ \\
~ & \indent\indent and $l = env_V \; \text{next}$ \\
~ & \indent\indent and $env_V'' = env_V[x \mapsto l][\text{next} \mapsto \text{new} \; l]$ \\
~ & ~ \\
\caption{Transition rules for the variable declarations.}
\label{tab:VarDecl}
\end{longtable}

\subsection{Function Declaration}
The transition rules for the function declarations are on the form: $env_V \vdash \langle D_P, env_P \rangle \rightarrow_{DP} env_P'$

\fxfatal{bla bla bla}
\begin{longtable}{l l}
\longtablesetting{2}
[FUNC-DEC] & $\dfrac{env_V \vdash \langle D_P, env_P[p \mapsto (S, env_V, env_P)] \rangle \rightarrow_{DP} env_P'}{env_V \vdash \langle \text{func} \; p \; \text{is} \; S; D_P, env_P \rangle \rightarrow_{DP} env_P'}$ \\
~ & ~ \\
\caption{Transition rules for the function declarations.}
\label{tab:ProcDecl}
\end{longtable}

\subsection{Array Declaration}
The transition rules for the variable declarations are on the form: $\langle d_A, env_V, sto \rangle \rightarrow_{DA} (env_V', sto')$

\fxfatal{bla bla bla}

\end{document}
