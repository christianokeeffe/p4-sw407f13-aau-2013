\section{Lecture 1 Exercises}

Review Questions 1-30, sebesta chapter 1
\begin{enumerate}
	\item Fordi det er nemmere for ham at skrive programmer når han kender til baggrunden for sprog
	\item Jo mere viden der er om programmeringssprog, jo bedre bliver fremtidige sprog
	\item Fortran
	\item COBOL
	\item LISP
	\item C
	\item Det bliver uoverskueligt at lære sproget, da man ikke nødvendigvis lærer alle features i sproget. Writeability
	\item Skaber forvirring fordi programmet bliver mindre læseligt, da operatorer måske ikke giver logisk mening mere.
	\item Det betyder at der relativt få måder at samle primitive konstruktioner på. I C er et eksempel at et array kan være enhver type, pånær void. Alt bliver parset med værdi, pånær arrays, som bliver adressen. 
	\item ALGOL 68
	\item if else, og do while
	\item for example The use of a sub-program, to implement a sort-algorithm.
	\item Altid producerer det samme resultat med det samme input. 
	\item Hvis man giver et sub-program forkerte parametre, så får man et upålideligt resultat
	\item At have to eller flere forskellige navne til at tilgå den samme hukommelses-celle
	\item Fejlhåndtering på run-time
	\item Det at kunne læse et sprog, gør det også hurtigere at skrive kode.
	\item Jo højere sprog-niveau, jo mere skal compileren lave
	\item Det skal tage færre mennesketimer at skrive kode, fordi programmører er blevet dyrere end computerne. 
	\item Imperitive sprog
	\item Manglende type-check og utilstrækkelighed af kontrol-statements 
	\item Data-abstraktion, indkapsling og nedarvning, og dynamisk metode-binding
	\item Smalltalk
	\item Pålidelighed vs. cost of execution
	\item Compilation, pure interpretation, hybrid implementation systems
	\item Compiler, fordi den kompilerer, og så kører programmet, hvor en interpretor kompilerer på runtime (nærmest)
	\item Er en database med værdier i kompileringsprocessen, som skal bruges i flere forskellige trin af kompileringsprocessen.
	\item Inkluderer libraries for eksempel
	\item Det er den primære begrænsende feature i en von Neumann arkitektur. Hastigheden mellem en computers processor og dens hukommelse bestemmer normalt computerens hastighed. Flaskehalsen er altså at instruktioner kan udføres hurtigere end de kan overføres til CPU'en
	\item Nemmere debugging fordi man kan se værdier af variabler. 
\end{enumerate}